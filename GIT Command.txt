------------------------------
Understanding GIT with D3
Helps us to understand like a graphically
http://onlywei.github.io/explain-git-with-d3/
------------------------------
To list out the conflict files
------------------------------
git diff --name-only --diff-filter=U
----------------------
To display help in Git
----------------------
git help <command>
------------------------------------------------
To display the version of GIT
------------------------------------------------
$ git --verison
------------------------------------------------
To display all the files that are tracked by git
------------------------------------------------
git ls-files
This lists all the files that git is tracking.

---------------------------------------------
Displaying current User and Email of the repo
---------------------------------------------
git config user.name
git config user.email

---------------------------------------------
Displaying global User and Email of the repo
---------------------------------------------
git config --global user.name
git config --global user.email

------------------------------------------------
Viewing the changes of all files using commit id
------------------------------------------------
list's out the files and changed area's output similar to git diff. For this we use the show command. The syntax is

git show commit_id
git show fe6458761c7c15652386778e50ce34d59aa3c826


----------------------------------------------------
How can I view a git log of just one user's commits?
----------------------------------------------------
$ git log --author="Jon"


----------------------------------------------------------------------------------------
Viewing the changes of all files using commit id (list out / modified files in a commit)
----------------------------------------------------------------------------------------
Approach -1
-----------
One of the prefered approach for viewing the files that were commited for a commit id. The general syntax is 
$ git diff-tree --no-commit-id --name-only -r commit_id
where
The --no-commit-id suppresses the commit ID output.
The --pretty argument specifies an empty format string to avoid the cruft at the beginning.
The --name-only argument shows only the file names that were affected. 
Use --name-status instead, if you want to see what happened to each file (Deleted, Modified, Added)
The -r argument is to recurse into sub-trees

eg:
$ git diff-tree --no-commit-id --name-only -r 666fe9bff80b7a31cbe740709519e17fb9c634de
PPD Common/src/main/java/com/ge/ppd/common/model/Projects.java
PPD Common/src/main/java/com/ge/ppd/common/service/ProjectServices.java
PPD Common/src/main/java/com/ge/ppd/common/service/impl/ProjectsServicesImpl.java
PPD Common/src/main/java/com/ge/ppd/web/dto/ProjectsDto.java

Approach-2
----------
Less preferred for scripts, because it's a porcelain command; meant to be user-facing. The general syntax is
$ git show --pretty="" --name-only bd61ad98

eg:
$ git show --pretty="" --name-only 666fe9bff80b7a31cbe740709519e17fb9c634de
PPD Common/src/main/java/com/ge/ppd/common/model/Projects.java
PPD Common/src/main/java/com/ge/ppd/common/service/ProjectServices.java
PPD Common/src/main/java/com/ge/ppd/common/service/impl/ProjectsServicesImpl.java
PPD Common/src/main/java/com/ge/ppd/web/dto/ProjectsDto.java


--------------------------------
Getting the latest from a branch
--------------------------------
When we use the pull keyword we are fetching all the informations from the repository i.e from all the branches and multiple repo if present.
In such case its not safe to use pull keyword. what we need to do is 
1. first fetch all changes from the repo this will take all the changes  from the repository
and store it in our local .git folder but it will not merge with the file system. (git fetch origin)
2. secondly merge the prefered repo manually(git merge origin/develop)
git fetch origin
git merge origin/develop

-----------------------------
Fetch all Changes from remote
-----------------------------
git fetch --all

Adding files to Git
-------------------
git add prepares the new and existing files for staging . It adds all the new and existing file/directories to the staging area
1.git init
2.git add README.md
3.git commit -m "first commit"
4.git remote add origin git@github.build.ge.com:502643138/mv-expert-ui.git
5.git push -u origin master

List All Branches From Remote
-----------------------------
git branch --remote

GIT Fetch
---------
If a new branch is added then we need to do a git fetch so that all the branches will be copied on our m/c. i.e it will be copied to our local .git folder.
Cloning new branch
------------------
git clone git@github.build.ge.com:DataBridge/databridge.git
enter the passphase

git clone git@github.build.ge.com:SIMSDEV/sims.git
enter the passphase

Geting started with the project means getting started with the latest version of the project. But in git you have all the versions of the project from when the
project is started. This process is called cloning.
For this get the clone url from the git repository.

git clone cloneUrl
Upon success message you now have all the latest source code and you are now ready to work.


Cloning a specific branch
-------------------------
git clone git@github.build.ge.com:DataBridge/databridge.git@develop-june

Checkout
--------
git checkout sims_post_release_7_merge

To revert a code 
git checkout -- src/main/resources/log4j2.json

Deleting a branch (Develop )from local
--------------------------------------
git branch -D develop

Adding a file
-------------
git add prepares the new and existing files for staging . It adds all the new and existing file/directories to the staging area
git add filename.extension
git add .

-----------------------------------
Updating the git index while adding
-----------------------------------
git add -u
if we are doing many operation such as add, modify and delete then we can forcefully update the index of git using the command git add -u

Commit
------
//Before Commiting a set of files we need to add them. then you need to use the commit command.

git commit
git commit -m "My first Commit inline"
man git-commit

Amending Commits
----------------
There can be situations where we have commited our work. But there can be small fixes while testing in that case we can fix the issue and perform a commit. so in this case in the history we have 2 entries one is the work completed message and the other is fix done message. But if we want the second commit to be added to the first then we use the git commit amend option. While using git commit amend option we can modify an existing file, remove a file or add a new file and make sure its in the staging area. git commit amend option works for all the possible scenarios.

Now we will look at the git amend command, so the git amend command is going to be anything that you would use when you need to modify something about the last commit whether that the commit message itself or some of the details such as adding or removing a file or just changing part of the code in one of the files. Anytime we are going to rewrite history and using the amend command is going to rewrite history so we need to be little careful.You only want to do this on a local branch or own your own branch at the public no one has else branched off or is relying on the history of your branch because once you change that commit history you are going to create a huge conflict with anybody who is relying on that history. So you definitely not want to use this on master. 
So let go ahead and take a look at what it takes to perform an amend to our previous commit.

1.Verifying History
$ git log
commit 9d3ccf4f2e1ea7fa9a760d533fb5f769a096e53c (HEAD -> stash-master, branch-stash-test)
Author: Raul <e.rahuljacob@gmail.com>
Date:   Tue May 19 11:28:58 2020 +0530

    Made a stash and copied to a new branch

commit baa6a975ee11bc052810291e452701782f95377b (origin/master, stash-test, master)
Author: Raul <e.rahuljacob@gmail.com>
Date:   Wed May 6 10:48:12 2020 +0530

    modified source

commit 31339251a80ddb58a6d6f8072cfdb3324748b369
Author: Raul <e.rahuljacob@gmail.com>
Date:   Wed Apr 29 23:08:18 2020 +0530

    Banner Text Added

commit 919cce6a900db0cb29a04688daa1163f32f4f13a
Author: Raul <e.rahuljacob@gmail.com>
Date:   Sun Apr 5 12:59:21 2020 +0530

    Junit 5 added for pom.xml

Now we are on the commit id 9d3ccf4f2e1ea7fa9a760d533fb5f769a096e53c. So for demo purpose we are going to checkout to a new branch.
2.Creating a new branch
$ git checkout -b amend-test
Now we have switched to amend-test branch.

3.Now we modify the pom.xml file
<!-- Adding Comment line to test Git Ammend Command -->

$ git status
On branch amend-test
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   pom.xml


4.Now we add the file
$ git add .

5.Commit the file.
$ git commit -m "I am doing a commit to understand amend commit."

6.View the history
$ git log --oneline
423c12a (HEAD -> amend-test) I am doing a commit to understand amend commit.
9d3ccf4 (stash-master, branch-stash-test) Made a stash and copied to a new branch
baa6a97 (origin/master, stash-test, master) modified source
3133925 Banner Text Added
919cce6 Junit 5 added for pom.xml
222215d Initial Springboot Setup
42e9b3c Initial Springboot Setup

Now our change is present in the GIT history for ever. 

7.Commit using amend option
Since our change is present in the GIT history for ever. Now we need to change it. So i want to make a note on 423c12a at this point we at that commit and what we want is to just quickly run a git commit with amend and i am not going to add a message to this because i want you to show you something that's not quite setup right about my system. 
$ git commit --amend

8.View the history
$ git log --oneline
7d84b5a (HEAD -> amend-test) I am doing a commit to understand amend commit.
9d3ccf4 (stash-master, branch-stash-test) Made a stash and copied to a new branch
baa6a97 (origin/master, stash-test, master) modified source
3133925 Banner Text Added
919cce6 Junit 5 added for pom.xml
222215d Initial Springboot Setup
42e9b3c Initial Springboot Setup

Now if you see you no longer can see the 423c12a commit id, since you did a commit amend the commit id changed and we have a new comit 7d84b5a7fb05d43d8d4981a21f26d366129ca03a.

9.Commit using amend option
Now our previous commit id is 7d84b5a7fb05d43d8d4981a21f26d366129ca03a. Now we are going to do a commit using amend option by giving a message "I want to learn commit amend and am testing more using amend option"
$ git commit -m "I want to learn commit amend and am testing more using amend option" --amend
[amend-test 054120a] I want to learn commit amend and am testing more using amend option
 Date: Thu May 21 16:48:31 2020 +0530
 1 file changed, 1 insertion(+), 1 deletion(-)

10.View the history
$ git log --oneline
$ git log --oneline
054120a (HEAD -> amend-test) I want to learn commit amend and am testing more using amend option
9d3ccf4 (stash-master, branch-stash-test) Made a stash and copied to a new branch
baa6a97 (origin/master, stash-test, master) modified source
3133925 Banner Text Added
919cce6 Junit 5 added for pom.xml
222215d Initial Springboot Setup
42e9b3c Initial Springboot Setup

Now if you see i have a new commit id and the new messge has been displayed.

Orphen Commits
Note: We have done 2 amends. So our initial commit was 423c12a, then later on we did one amend commit and it changed to 7d84b5a and later on we again changed to 054120a. So 054120a is our final commit. But we have 2 commits 423c12a and 7d84b5a these commits are called orphen commits and they are unreachable at this point and they are not going to show up anywhere and i am going to show you how to clean those up eventually.

--------
+ reflog
--------

Orphen Commits
(Continuation from amend commit)
We have done 2 amends. So our initial commit was 423c12a, then later on we did one amend commit and it changed to 7d84b5a and later on we again changed to 054120a. So 054120a is our final commit. But we have 2 commits 423c12a and 7d84b5a these commits are called orphen commits and they are unreachable at this point and they are not going to show up anywhere and i am going to show you how to clean those up eventually.

So if a commit id is unreachable they are called orphen commits. In our above example we have 423c12a and 7d84b5a as orphen commits.
There is no tag or branch or pointer of any sort going directly to these commits. So they are called unreachable but they are still in my git history and i could still actually retrieve them and check them out. Those commit id's. So this is really handy if you need to see something that's not necessarily reachable but exists and you know it exists and you need to get back to that point.

When you type
$ git log 
you can see commit id's that are reachable means you cannot see orphen commit id's.

To view all the commit's including orphen commit
------------------------------------------------
$ git reflog

054120a (HEAD -> amend-test) HEAD@{0}: commit (amend): I want to learn commit amend and am testing more using amend option
7d84b5a HEAD@{1}: commit (amend): I am doing a commit to understand amend commit.
423c12a HEAD@{2}: commit: I am doing a commit to understand amend commit.
9d3ccf4 (stash-master, branch-stash-test) HEAD@{3}: checkout: moving from stash-master to amend-test
9d3ccf4 (stash-master, branch-stash-test) HEAD@{4}: merge branch-stash-test: Fast-forward
baa6a97 (origin/master, stash-test, master) HEAD@{5}: checkout: moving from branch-stash-test to stash-master
9d3ccf4 (stash-master, branch-stash-test) HEAD@{6}: commit: Made a stash and copied to a new branch
baa6a97 (origin/master, stash-test, master) HEAD@{7}: reset: moving to HEAD
baa6a97 (origin/master, stash-test, master) HEAD@{8}: checkout: moving from stash-master to branch-stash-test
baa6a97 (origin/master, stash-test, master) HEAD@{9}: reset: moving to HEAD
baa6a97 (origin/master, stash-test, master) HEAD@{10}: checkout: moving from master to stash-master
baa6a97 (origin/master, stash-test, master) HEAD@{11}: checkout: moving from master-stash to master


Now we can see in the above logs we have 423c12a and 7d84b5a as orphen commits. So when using $ git reflog you are displaying not only the reachable commit id's but also orphen commit id's.
Now by using reflog i can go to the point of both reachable or unreachable code. That is by typing the below command

$ git checkout 7d84b5a
Note: checking out '7d84b5a'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b <new-branch-name>

HEAD is now at 7d84b5a I am doing a commit to understand amend commit.

And it now say's you have checked out and you are now in a detached head state you can look around make experimental changes and commit them over. 
You can see now that i have a head pointer to the 7d84b5a so its there but i am in what's called a detached head.

Creating a new branch from 7d84b5a to rework
So I don't really want to make any commits but if i needed to work with that point what I could do is to create it as a new branch
$ git checkout -b resetting-to-7d84b5a-for-rework
Now you have switched to 7d84b5a branch.
And we have a valid pointer to that 7d84b5a commit id. So we have a valid commit and a valid branch.

So that's how we can go back to a branch that's no longer reachable and start working with it and we have already seen it from the reflog. 

Deleting the branch
-------------------
So now we are going to undo the changes. Now i am going to delete the branch 
$ git checkout amend-test
$ git branch -D resetting-to-7d84b5a-for-rework

View reflog history
-------------------
$ git reflog
054120a (HEAD -> amend-test) HEAD@{0}: checkout: moving from test to amend-test
7d84b5a HEAD@{1}: checkout: moving from 7d84b5a7fb05d43d8d4981a21f26d366129ca03a to test
7d84b5a HEAD@{2}: checkout: moving from amend-test to 7d84b5a
054120a (HEAD -> amend-test) HEAD@{3}: commit (amend): I want to learn commit amend and am testing more using amend option

Now we can see the history listed from index 0 to so on.  If you look at indes 1 and 2 we can see all the activities that we are doing in the GIT.
i.e we still have our history and we have an order from zero to whatever for the things that we have done. 

View reflog from a specific index
---------------------------------
So if you want to see what your reflog history was like at a specific point you could go from there.
$ git reflog HEAD@{20}
949a02f HEAD@{20}: commit: Pushing new changes to pom.xml
ad8a932 HEAD@{21}: commit: Quick fix after our stashing
baa6a97 (origin/master, stash-test, master) HEAD@{22}: reset: moving to HEAD
baa6a97 (origin/master, stash-test, master) HEAD@{23}: reset: moving to HEAD
baa6a97 (origin/master, stash-test, master) HEAD@{24}: checkout: moving from master to master-stash
baa6a97 (origin/master, stash-test, master) HEAD@{25}: checkout: moving from master-stash to master
9e1e75c HEAD@{26}: commit: In Master modifying pom.xml
4afb4c3 HEAD@{27}: commit: master : Changes to application.properties in master-stash branch
baa6a97 (origin/master, stash-test, master) HEAD@{28}: reset: moving to HEAD
baa6a97 (origin/master, stash-test, master) HEAD@{29}: checkout: moving from master to master-stash
baa6a97 (origin/master, stash-test, master) HEAD@{30}: checkout: moving from master-rebase to master
8f1875d HEAD@{31}: merge rebase-conflict: Fast-forward

Now as you can see it will start displaying history from 20 onwards.

View reflog from a time period
------------------------------
Usually it will be difficult to identify first the commit id by checking the commit message and based on the commit id you need to execute the git reflog and see the index. but we also have another option to provide a time period like the number of days. eg: 3 days ago.

$ git reflog HEAD@{3.days.ago}
If todays date is 22.05.18 then it will display the history from 19.05.18 i.e (22-3=19)

i can also give $ git reflog HEAD@{2.weeks.ago}
We also have other options
1 minute ago
1 hour ago
1 day ago
any number of minutes ago
any number of hours ago
any number of days ago
one week ago
one month ago
yesterday a year ago

or a specific date
$ git reflog HEAD@{2017-08-25}

$ git reflog HEAD@{2020-05-06}
de3926f HEAD@{Wed May 6 15:40:32 2020 +0530}: rebase: checkout master-rebase
92f0c76 HEAD@{Wed May 6 15:39:50 2020 +0530}: checkout: moving from master-rebase to rebase-conflict
de3926f HEAD@{Wed May 6 14:58:44 2020 +0530}: commit: Modifed pom.xml for conflicts in master-branch
af753d3 HEAD@{Wed May 6 14:55:35 2020 +0530}: checkout: moving from rebase-conflict to master-rebase
92f0c76 HEAD@{Wed May 6 14:04:29 2020 +0530}: commit: Modified pom.xml for conflicts
baa6a97 (origin/master, stash-test, master) HEAD@{Wed May 6 13:51:16 2020 +0530}: checkout: moving from master-rebase to rebase-conflict
af753d3 HEAD@{Wed May 6 13:50:19 2020 +0530}: commit: Adding Message in pom.xml Before Rebase Conflicts
baa6a97 (origin/master, stash-test, master) HEAD@{Wed May 6 13:48:12 2020 +0530}: checkout: moving from master to master-rebase
baa6a97 (origin/master, stash-test, master) HEAD@{Wed May 6 13:45:32 2020 +0530}: checkout: moving from master-rebase to master
b164978 HEAD@{Wed May 6 13:11:53 2020 +0530}: merge rebase-test: Fast-forward
536dfa5 HEAD@{Wed May 6 13:09:31 2020 +0530}: checkout: moving from rebase-test to master-rebase
b164978 HEAD@{Wed May 6 12:59:11 2020 +0530}: commit: Comment added for springboot-starter-jpa in pom.xml

Now we can see we got the history from that specific date.


Now we will see couple of differences using reflog between commits as well as how we can clean up these unreachable commits.

Looking between two commits or difference between two commits
-------------------------------------------------------------
Now i want to see the differences b/w the commits b164978 and af753d3 for that i provide the command
consider their HEAD's are at 20 and 21
$ git diff HEAD@{21} HEAD@{20}

To view in our difftool
$ git difftool HEAD@{21} HEAD@{20}

We also can give a specific time period
$ git diff HEAD@{10.minutes.ago} HEAD@{1.week.ago}

The above command tell us the differneces made between from last week to the last 10 minutes ago.
That basically shows us how we can use the reflog to compare the different head references head for HEAD{21} and HEAD{20} or different time commits that we can use. Also there are multiple time commits that we can use and see how they work.

How to Clean up Orphen Commits using reflog.
-------------------------------------------
In order to do this we will also use the garbage collector as well. While clean up you have different options such as delete unreachable code which in one week, delete unreachable code created in a month etc.
But we will see how we can delete all the orphen commit id records in one go.
$ git reflog expire --expire-unreachable=now --all
Now what you will see is this is I hit this all that did was set a variable and so that means that any time i run the grabage collector now with this reflog expire on a pruning operation it will clean up everything as long as that's stays in scope. So we give the command 
$ git gc --prune=now
Enumerating objects: 392, done.
Counting objects: 100% (392/392), done.
Delta compression using up to 4 threads.
Compressing objects: 100% (270/270), done.
Writing objects: 100% (392/392), done.
Total 392 (delta 114), reused 0 (delta 0)
Removing duplicate objects: 100% (256/256), done.

So what's that going to do is it will clean up all the orphen references. And it will be gone. So we can delete the unreachable commits.
So our history is clean, we have removed all the unreachable referneces and now we only have the reachable commits.

To verify this we can check our reflog command
$ git reflog
we can see only reachable commits. We cannot see any unreachable commits.

------------------------------
Initialize/Create a repository
------------------------------
git init - Converts the current folder into a git repository.

git init myGitFolder - Creates a folder myGitFolder and converts into a git repository.
c:\user\git\myGitFolder\.git\

Now we have created a complete repository. Means we have a .git folder and our working directory.

We also have something called bare bone repository. To create a bare repository simply pass in a flag.

git init --bare barerepo
This creates a barerepo with the git folder but does not have a working directory. Now what is the use consider this like a point of collaboration, if you drop this directory somewhere else where others can access this via secured shell you just setted up a very simple git server. you can now use that a point of colaboration to share work back and forth.


List .git folder
----------------
ls -al

List the remote git repo
------------------------
git remote -v

Git Push
---------
git push origin sims_release_7_Hotfix

Git Stash
---------
There can be situations where we need not commit few files, they may be config related or something. In such case such files need not be shown when typing git
status command.
So we stash them, where the file will be moved to a staging area.later on you can bring back from the staging location to your workspace.

git stash --adds the list of files to git staging area.
git stash pop --reverts or clears the files from the staging area to your workspace.

Know your branch
----------------
git branch
Lists all branch
----------------
git branch -a

Create New Branch in local and checkout from another branch
-----------------
git checkout -b salesorder (Created a sales order branch local repo)
git push origin salesorder (Created a sales order branch on remote repo)
git checkout -b develop origin/develop

Deleting a branch from Remote
-----------------------------
git push origin --delete branchName

git push origin --delete jpa-many-to-many-basic

Delete Branch
-------------
delete the hotfix branch
git branch -d hotfix
Deleted branch hotfix (3a0874c).

Pull from master
-----------------
git pull origin master
git pull (pulls code from current branch)

Merging from branch to master
This can be done in 2 ways.
1. From command prompt
	In command prompt its straight forward
	git pull origin master
	git push origin master
2. From GIT Web
But in Web we have a review process first then once its over we push the code to master.
Step 1 : Go to repository (https://github.build.ge.com/DataBridge/)
Step 2 : Next to the branch drop down we have a button called New Pull Request
Step 3 : Compare changes select the branch where change needs to be done. You can see the list of files changed and their changes
Step 4 : In this step you can do a code reviewing you need to select Reviewers by clicking on the settings button. if no reviewer then verify it yourself and if ok you can click on the Create Pull Request. 
Step 5 : Then you can see a message This branch has no conflicts with the base branch -> Click on the button Merge pull request.
Step 6 : Give the comment, by default the last commit message will be displayed then click the button Merge.
Step 7 : Once merging is complete you will get a message Pull request successfully merged and closed.

Another way of doing merge to master

1.Do the changes in branch salesorder
2.Push the changes to remote sales
3.check out master from local
	$ git checkout master
4.merge the branch sales order with master	in your local
	$ git merge salesorder
5.once merged then push the code to remote master
	$ git push master	
Git Stash
---------
git stash => It is equvalent to git stash push. Move the change files to temp location (stash)
This is used when we are working on one branch where we have uncommited code, then we have a requirement to work on another branch. So before checkout the new 
branch standing from our current branch we go a git stash(moves change files to a temp locaton)

git stash pop
Restores the old changes back to our branch.

git stash list
Displays when it was stashed. Or how many items are stashed.

git stash show
Displays the stashed files

Generating a new SSH key (via gitbash)
------------------------
1. Open Git Bash.
2. Paste the text below, substituting in your GitHub email address
ssh-keygen -t rsa -b 4096 -C "e.rahuljacob@gmail.com"
or
ssh-keygen -t rsa -b 4096
3.When you're prompted to "Enter a file in which to save the key," press Enter. This accepts the default file location.
Enter a file in which to save the key (/c/Users/you/.ssh/id_rsa):[Press enter]
4.At the prompt, type a secure passphrase. For more information, see "Working with SSH key passphrases".
enter passphrase (empty for no passphrase): [Type a passphrase]
Enter same passphrase again: [Type passphrase again]


Generating a new SSH key (via gitGui)
------------------------
1. Open Git UI.
2. Menu -> Help
3. On top left hand side there is generate SSH Click.
4. Upon clicking a new file will ge generated to C:\Users\Raul\.ssh folder.

How to remove files that were alredy added to GIT (remove .class files)
-----------------------------------------------------------------------
--Make sure your .class files were not already added to the index
git rm -r --cached *.class
the files will be remived from index. then commit them. Then add to gitignore.


Creating a new branch (temp branch) from the current branch based on a commit fa1f8225cb62aa272486cbf42e3abce2b9154df1
-----------------------------------------------------
git checkout -b temp fa1f8225cb62aa272486cbf42e3abce2b9154df1

Creating a new branch(Develop) from another branch (temp)
git checkout -b develop temp

git remote -v

Merging from one branch to another (Merging of 2 branches)
----------------------------------
Consider you have one branch TASK A, and you have antoher branch say TASK B.
Now you need to merge all the code from TASK A branch to TASK B branch. do the following steps
1. once you finish your chages in TASK A branch(commit or sync with current branch or take a pull)
2. do a pull for TASK A to ensure that we have all the latest code.
3. git checkout TASK B
4. From branch B finish your task (by comitting or pushing your code with current branch or take a pull)
5. do a pull for TASK B to ensure that we have all the latest code.
6. for merging stay in TASK B branch and type git merge TASK A

Reverting a file from current branch
------------------------------------
git checkout filename
git checkout  src/main/resources/application.properties


Reverting a file or comparing a file with previous commits
----------------------------------------------------------





Reverting a commit in local (Make sure the data is not pushed to server)
---------------------------
1. Type git logs and check you commit is there also note your commit id and previous users commit id.
Please take the backup of your changes before giving the step 2
2. git reset --hard HEAD^
you can see the message "HEAD is now at 9e148823 created a utilty class for cover page name generation and other utilites to be used in print volume."
this HEAD at 9e148823 is your previous commit. (all your changes will be lost hence take the backup of your changes before this command)


Reverting the entire branch to a particualr commit.
---------------------------------------------------
1. Type git logs note the previous users commit id.
Please take the backup of your changes before giving the step 2
2.
git reset --hard b5beb75242d1562ea9f46fead6ab43bf042c8ef0
HEAD is now at b5beb7524 Print volume code added
3. Take latest pull to get all the codes

Reverting the local repository with the remote repository
---------------------------------------------------------
Setting your branch to exactly match the remote branch can be done in two steps:
git fetch origin
git reset --hard origin/master

**************************************************************
Configuring your email and username
-----------------------------------
$ git config --global user.name First Last
$ git config --global user.email myemail@domain.com

Listing your configuration properties
-------------------------------------
1. Lists the global properties(for all repositories)
		file location : (~/.gitconfig)
$ git config --global --list

Another approach opens file in default editor
git config --global -e

2. Lists the local properties (particular repository)
		file location : (.git/config)
$ git config --list --local

**********************************************************************************************************************
Git configuration variables can be stored at three different levels. Each level overrides values at the previous level
----------------------------------------------------------------------------------------------------------------------
1. System level (applied to every user on the system and all their repositories)
	- to view, git config --list --system (may need sudo)
	- to set, git config --system color.ui true
	- to edit system config file, git config --edit --system
2. Global level (values specific personally to you, the user).
	- to view, git config --list --global
	- to set, git config --global user.name xyz
	- to edit global config file, git config --edit --global
3. Repository level (specific to that single repository)
	- to view, git config --list --local
	- to set, git config --local core.ignorecase true (--local optional)
	- to edit repository config file, git config --edit --local (--local optional)

How do I view all settings
	- Run git config --list, showing system, global, and (if inside a repository) local configs
	- Run git config --list --show-origin, also shows the origin file of each config item

How do I read one particular configuration
	- Run git config user.name to get user.name, for example.
	- You may also specify options --system, --global, --local to read that value at a particular level.	


tree command
------------
 - tree command gives us a recursive directory listing.
tree .git

Initialize/Create a repository
------------------------------
git init - Converts the current folder into a git repository.

git init myGitFolder - Creates a folder myGitFolder and converts into a git repository.
c:\user\git\myGitFolder\.git\

Now we have created a complete repository. Means we have a .git folder and our working directory.

We also have something called bare bone repository. To create a bare repository simply pass in a flag.

git init --bare barerepo
This creates a barerepo with the git folder but does not have a working directory. Now what is the use consider this like a point of collaboration, if you drop this directory somewhere else where others can access this via secured shell you just setted up a very simple git server. you can now use that a point of colaboration to share work back and forth.

graph history
-------------
git log --oneline --graph
This shows all the version's of our project, The asterisks(*) and yellow line indicates all the versions of our project. And these versions are available in our local hard disk.

Git States / Checking Statuses
------------------------------
When interacting with GIT there are 4 states for a file. 
1.Untracked - Which means that file is not under control by GIT
2.Unmodified - GIT knows about the file, but it hasn't changed.
3.Modified - GIT knows about it and the file has been changed.
4.Staged - That the file is ready to commit.

git status
git add fileOne - add this file to the stage or add this to the index.
git add prepares the new and existing files for staging . It adds all the new and existing file/directories to the staging area
One file can be in multiple stages. Such as consider
1.one file fileOne is added to git repo.
2.now check the status. - you can see fileOne is in the staged row
3.now modifiy the fileOne again.
4.now check the status - you can see fileOne is present in the staged row as well as in the modified row. Means one file maintains different stage or parts.

git status -sb (summary & branch)

git config --global alias.st 'status -sb' //alias name
git st - now if i execute git st it will check the config alias.st and find it correcponds to the command 'status -sb'

Git Status with short description
$ git status -s

Git Commit
----------
Commit - Creates a snapshot and saves to GIT History. When you are comitting you are using the index, its kind of like a workbench to put the whole parts together this is called staging area or staging changes.
git commit will take a snapshot and record all the changes into the repository
eg:Consider i have a file - file1
1. I make couple of changes to this file1 you add one line in the middle and modify an existing value. save
2. Check the status.
File is in the modified stage - nothing is in staged.
3. If i need to see the changes. then type 
git diff
4. You can see 2 hunks - hunks is nothing but all the things that are after the (2 atherate) @@ lines in the editor, after making sure the changes  i now type git status to ensure once again.
5. git add file1 - moves the unmodified file to stage
6. git status shows in green which tells us that its in stage and ready to commit.
7.git commit - now an editor is opened and it tells the status to be commited. provide the commit message and quit.
or git commit -m 'commit message'

Another quick way to commit.
----------------------------
If your modified file is not staged then type
git commit -av (all changes & verbose) this drops into my editor which shows the difference or changes to the file. I can quit by providing an empty commit message and quit. or provide the commit message and quit (wq).

man git-commit

Advance Commits
---------------
Now consider the above example where we made changes to a file by adding a new line and modifying a value. when we type git diff we see 2 hunks.
Where the first change (adding a new line) and the second change (modifying an existing line) both changes are not dependent, they are independent to each other. so we want to push this as separate commits not as a single one. In this case index will help us, the index is helps us to stage different parts of the file at different times there are too many ways.
1. command line
git add --patch
-Appears as differend hunk go to each one and type y or n. give one as y and the other as n
-Now type git status you can see one fileOne in the staged and the same fileOne in modified too.
-Now to understand better type git commit -v (verify)
-Give the comment and exit.
Now type git status
-Give you can see the file is in the modified area
Now type git commit -av

2.On GUI
Open git gui go to the hunk and right click Stage Hunk for Commit. then this change will move to stage.
Now one commit this file with the message
Now we have only the remaining one hunk, double click and move it to stage
And commit with a message.

GIT Hosting:
------------
In order to work with other people you need to put the code so that others can also access them. This is generally called Git Hosting.
There are several ways to accomplish it.
1.SSH
a.Best with Linux Server
b.Need to have a git user account
c.Each user should create a SSH Key
d.SSH in and create repository
e.git@servername:project.git
f.git-shell
Pros
a.Free
b.No specific s/w or h/w we already have everything.
c.Very secure
Cons
a.GIT only
b.Highly technical not user freiendly
c.Many steps 
d.audit control is difficult.
e.No auditing
2.Internet Hosting
a.GitHub,GitLab,Bigbucket
b.Easy administration
c.Easy Project management
d.Accessable for non-technical
e.Access over HTTPS
f.Extra
	Issue Tracking
	code review
	documentation.
	pull request.
3.On-Premises hosting
a.Runs on your machine
b.Runs inside your n/want
c.Github Enterprise,Stash, GitLab
d.Equivalent to Internet Services.


Remote Repositories:
--------------------




	




Writing a file
--------------
echo "Test Git Quick Start demo" >> start.txt
This will write the content into a new file start.txt

-----------------
Displaying a file
-----------------
cat start.txt
This is display the contents of the file start.txt
----------------------------------------------------
Installing a Text Editor and configure to Git
----------------------------------------------------
Now we will configure the Notepad++ with Git so that we can run with command environment.
1. Open git bash and type 
$ notepad++
if we get an error notepad++ command not found then we need to install it.
2. Exit gitbash
3. Find where is notepad++ installed and copy the path i.e C:\Program Files\Notepad++
4. Copy the path to our environment variable path just like we did for java and all.
5. Open a new git bash and type
$ notepad++
And it opens.

----------------------------------------------------------------------
Provide Alias to notepad++ as npp and open a new instance of notepad++
----------------------------------------------------------------------
Its always recommended to create the file in user's home directory.
1. Open git bash
2. Type notepad++ .bash_profile
and press enter.
3. Notepad++ will prompt to confirm whether the new file should be created.
4. Type 
alias npp='notepad++.exe -multiInst -nosession'
Save and close the file.
5.close gitbash
6.open a new gitbash and type npp
The notepad++ is opened.

--------------------------------------------------
How to configure notepad++ as default text editor
--------------------------------------------------
1. Open gitbash
2. And lets view the current global config which are present
$ cat ~/.gitconfig
Press Enter. The symbol tild '~' denotes user's home directory.
3. now we use the git config command to make notepad++ as our default text editor
$ git config --global core.editor "notepad++.exe -multiInst -nosession"
Press Enter.
Now here the key "core.editor" is having a value "notepad++.exe -multiInst -nosession" so by this we have created notepad++ as our core-editor or default editor.
4. Verify the newly added property in the config file
$ git config --global --list
5. Now we will test whether it works so we will try to open the config file in edit mode
$ git config --global -e
Press Enter and the config file opens in notepad++

--------------------------------------------------------------------------------------
Adding the file and commiting the file in one step (Express Commit/Stream line commit)
--------------------------------------------------------------------------------------
A tracked file is a file which git is tracking actively. i.e any file that is commited or added to staging area. This is also called as Express Commit.
git commit -am "Commiting Files As Per the Defect In Rally"

----------------------------------------
To find whether a file is tracked or not
----------------------------------------
git ls-files
Identifying the tracked file
	- Add a new file to the repo (xyz.txt)
	- type the command $ git status and you can see xyz.txt is untracked.
	- also type git ls-files (the file xyz.txt won't be listed)
	- type git add xyz.txt
	- git status now the file will be tracked and its a new file.
	- also type git ls-files (the file xyz.txt will be listed)
	

One of the advantages of staging areas is we build up our files for commit. i.e we only want to use the -a parameter in the commit command when we dont want to add any changes to that commit, we make it simple and straing forward edit to an existing file. when we have a change that will expand multiple file then we definitely want to use the staging area.

-------------------------
Adding files recursively
-------------------------
git add .

-----------------------------------
Updating the git index while adding
-----------------------------------
git add -u
if we are doing many operation such as add, modify and delete then we can forcefully update the index of git using the command git add -u

--------------------------------
Backout Changes (Revert Changes)
--------------------------------
a) From Staged to Unstage (Changes done to the file will be present only thing is the file will be moved from staged to unstage area)
git reset HEAD filename.txt
Now if i type git status, i can see the file has moved from stage to unstaged area

b) To revert latest from repo(I dont want my changes in the file i.e i just want the state of the file that is last commited)
git checkout -- filename.txt
Now if i type git status i can see the file is not there in unstaged or staged area. since i have reverted the file to its last commit there is not changes hence it won't be listed. So now we have the lastest file that was last comitted.

-------------------------
Renaming or moving a file
-------------------------
We can do a delete or move operation in 2 ways 
1. Either using git mv or rm command
2. Or by using any file manager s/w that is associated with operating system

a) Renaming a file using git
git mv current_filename.txt new_filename.txt

git mv file-level3.txt level3.txt
Now if i do a ls
level3.txt
Now if i do a git status i can see that git has already understood a rename has taken place and the file is now in staged area but its not commited means i can also backout if needed.

b) Renaming the file at operating system level with out using git.
mv current_filename.txt new_filename.txt

mv file-level3.txt level3.txt
Now if i do a ls
level3.txt
Now if i do a git status git sees it as 2 operations
1. It see's that you deleted the old file (staged area)
2. And added a old file. (untracked file)
So now we need to add the file, since we have done this outside our git environment, we use add command with an extra parameter.
	git add -A
	the option -A will add any files that is recursively changed but also it will update any files that is renamed, moved or deleted in the working directory
Now if i do a git status i can see that git has already understood a rename took place and the file is now in staged area and its not comitted.

c) Rename a file and backing it out.
	- git mv file-level3.txt level3.txt
	- ls => level3.txt
	- git status => file in staging area
	- now if we want to backout we can either use git reset HEAD level3.txt or we have an easier approach git mv level3.txt file-level3.txt
	- now if i type git status i can see a clean working directory, git tells us that there is no change.
	
d) Move the file to another directory
Moving a file from one level/folder to another level/folder
git currentfile.txt newpath
Now currentfile.txt will be moved from current directory to newpath directory

git level2.txt dirlevel3
now if we do ls we cannot see the file level2.tx
we go up a level/folder cd dirlevel3
type ls
we can see the file level2.txt
Now if we type git status we can see that git has already staged the file and git understands that a move operation has taken place and its not comitted.

e) Move the file to another directory with out using git
mv file-level3.txt level3.txt
Now if i do a ls
level3.txt
Now if i do a git status git sees it as 2 operations
1. It see's that you deleted the old file (staged area)
2. And added a old file. (untracked file)
So now we need to add the file, since we have done this outside our git environment, we use add command with an extra parameter.
	git add -A
	the option -A will add any files that is recursively changed but also it will update any files that is renamed, moved or deleted in the working directory
Now if i do a git status i can see that git has already understood a rename took place and the file is now in staged area and its not comitted.

--------------
Deleting Files
--------------
a) Deleting an untracked file
We will create a simple file named doomed.txt and add some contents.
 - Now if i type git status i can see one untracked file doomed.txt
 - Now id i want to delete this by using the git rm command
 - git rm doomed.txt -> git will complain that doomed.txt didn't match any files, this is because its untracked file. so we need to use the operating system's delete functionality for deleting the file.
 - rm doomed.txt
 - if i do a ls the file is gone, if i do a status i have a clean working directory.
 
b) Deleting an tracked file
We will create a simple file named doomed.txt and add some contents.
 - Now if i type git status i can see one untracked file doomed.txt 
 - Add the file git add doomed.txt
 - Now type status  we can see doomed.txt is not added to staging area commit the file.
 - Now type git ls -files towards the bottom we can see doomed.txt
 - Now one way to delete the file tracked by git is by using the git rm command, git rm filename.txt
 - git rm doomed.txt
 - now if we type ls command we can see that the file doomed.txt is not listed in the directory
 - now if we type status git has staged the file by identifying it as deletion operation has taken place and is not comitted.
 
c) Backing out a deleted file from staged area. 
 We will create a simple file named doomed.txt and add some contents.
 - Now if i type git status i can see one untracked file doomed.txt 
 - Add the file git add doomed.txt
 - Now type status  we can see doomed.txt is not added to staging area commit the file.
 - Now type git ls -files towards the bottom we can see doomed.txt
 - Now one way to delete the file tracked by git is by using the git rm command, git rm filename.txt
 - git rm doomed.txt
 - now if we type ls command we can see that the file doomed.txt is not listed in the directory
 - now if we type status git has staged the file by identifying it as deletion operation has taken place and is not comitted.
 - Now we need to revert it so we type the reset HEAD command
 - git reset HEAD doomed.txt
 - Now if we type the ls command we cannot see the file doomed.txt yet 
 - Now if we type git status the file doomed.txt is still in the untracked list. so what did the reset HEAD command do it moved the file from the staging area to the untracked area.
 - Now we need to checkout the doomed.txt command.
 - Now if we type ls we can see the doomed.txt file in the directory
 - Now if i do a git status now it shows us a clear working directory.
 
d) Deleting an tracked file with out using git
We will create a simple file named doomed.txt and add some contents.
 - Now if i type git status i can see one untracked file doomed.txt 
 - Add the file git add doomed.txt
 - Now type status  we can see doomed.txt is not added to staging area commit the file.
 - Now type git ls -files towards the bottom we can see doomed.txt
 - Another way to delete the file tracked by git is by using the rm command i.e with out using the git as prefix, rm filename.txt
 - now id i type ls i cannot see the file in the directory
 - if i type git status i can see the file is deleted and its in the staging area.
 - git add -A
 the option -A will add any files that is recursively changed but also it will update any files that is renamed, moved or deleted in the working directory
 - Now if i do a git status git now has the files staged.
 

History/Log
-----------
To view the git history type the command 
$ git log

We can understand more about by log command by typing the help command
$ git help log
It has several options and we will explore a few

$ git log
Displays the default view in reverse cronological order, i.e starts with the last commit.
Following informations are available 
1. commit followed by a long string (shaawvan). This long string is a unique identifier that tells git about every commit.
2. Next we have the author and email id.
3. Next is the date when the commit happened.
4. Next the commit message.

If we want the commit id's (shaawvan) to be shortened then
$ git log --abbrev-commit
In this the commit id is shortened it consist of 6 charaters which will help us to identify a commit.

One liner
$ git log --oneline

Now we will try another option
$ git log --oneline --graph --decorate
--online   : What this will do is it will compress all the information in one line.
--graph    : What this will do is provide an ascii graph depicting the branching graph
--decorate : Will add any labels or tags or any thing that sort of annotates our commits.

Another way to view the logs is by providing a range of commit ids
$ git log ae6f872...761b911

Another view is to display logs based on dates
$ git log --since="3 days ago"

Now lets view the commit history for an independent file
$ git log -- filename.txt
return's the commit for only specific file.

Listing out a specific file changes made on different commits
$ git log -p <path of the file>

Listing all the commits based on author
$ git log --author="Sandy Sam"

Git show command
----------------
$ git show commit_id;
Displays the given commit information
Following informations are available 
1. commit followed by a long string (shaawvan). This long string is a unique identifier that tells git about every commit.
2. Next we have the author and email id.
3. Next is the date when the commit happened.
4. Next the commit message.
5. And the difference basically what has changed.

----------
Git Alias
----------
How to add aliases in git
For eg: we have a big git command such as
	$ git log --all --graph --decorate --oneline
We can view a neat log history of all my commits in the git repository. But involves a lot of writing to be done for this display. So what i can do is i can write my own command that is an alias which will give me the exact same output but with a shorter command.

So to add an alias 'hist'
First i type git hist to check we have a existing command 'hist' in git. if i get an error git : 'hist' is not a git command then we can go ahead with this alias 'hist'
To create my own hist command i need to piggy back half of git config command. So i need to type
$ git config --global alias.hist "log --all --graph --decorate --oneline"
where --global -> we need the alias to be available regardless of our repository so that will be saved at the user level. 
	  alias -> any configuration setting that starts with alias dot allows us to create a command.
	  command -> We provide the full command in double quotes that i want to be issued leaving out the git keyword so in this case we just start with 
				"log --all --graph --decorate --oneline"
				double check the command and press Enter.
				
Now try the command
$ git hist
If the output is displayed then we added a new command in git as alias.

Where the aliases are Stored
-----------------------------
If we know where aliases are stored we can modify the command when needed. And since we are using git's config command we need to open the .gitconfig file in the user's home directory.
npp ~/.gitconfig
This opens the gitconfig file and all our aliases will be in the aliase section of git config file. we can see the name of the command hist and the full command.
We can modify save and re-run the $ git hist command to view the latest saved information.

------------------------------------------------
Ignoring Unwanted Files and Folders (.gitignore)
------------------------------------------------
In order to avoid Unwanted files and folders we use the facility of a text file called .gitignore. This .gitignore tracks all the files and folders that git should ignore.

In order to check whether a .gitignore file is present we use the command
	ls -al
	This lists all the hidden files in the directory.
However the .gitignore file should be present in the same level of .git folder.

If the file is not present the we can create a new file with the name '.gitignore'
Now the format of '.gitignore' is 
1. One expression per line.
2. The expression can be name of a specific file
3. The expression can be a name of the folder.
4. The expression can be a pattern like *.txt

a) As of now we will add a specific file, open '.gitignore' file and type
.DS_Store
Save and type git status, we can see the earlier file .DS_Store is not present in the untracked file. and the .gitignore file is modified or is untracked.
The .gitingore file is like any other ordinary file that need to be added to the version controller.
$ git add .gitignore

b) Now we will add a pattern *.log, open '.gitignore' file and type
*.log
So any file that ends with a .log will be captured by this inspection.
Type git status and we can see that the *.log file is not there in the untracked file where as the file .gitignore is modified.

c) Another scenario is a folder, open '.gitignore' file and type
log

----------------
cleanup and Push
----------------
Sometimes when we type git status we can see a message 'Your branch is ahead of origin/master by 14 commits' means we have 14 commits on our local branch but it not there in remote branch. Its time for us to synchronize remote and local. So before pushing its best practice to first take a pull first then push the code.
$ git pull origin master

Now to push the code
$ git push origin master
where origin refers to the name of the remote repository that we have given in this repository. It refers back to the github repository and master is the default branch.

--------------------------------------------
Configuring Merge Tool and Diff Tool for Git
--------------------------------------------
We can use any merge or diff tool with Git. In the demo we have seen how to configure P4Merge, since i am using WinMerge or ExamDiff we will configure these as the default merge or diff tool for Git.

Now we will configure the WinMergeU with Git so that we can run with command environment.
1. Open git bash and type 
$ WinMergeU
if we get an error WinMergeU command not found then we need to install it.
2. Exit gitbash
3. Find where is WinMergeU installed and copy the path i.e C:\Program Files (x86)\WinMerge
4. Copy the path to our environment variable path just like we did for java and all.
5. Open a new git bash and type
$ WinMergeU
And it opens.
Merge Tool
----------
git config --global merge.tool winmerge
git config --global mergetool.winmerge.path "C:/Program Files (x86)/WinMerge/WinMergeU.exe"

Note : With respece to windows we use backslash for specifying file paths but here we need to use forward slash for configuring paths in GIT.

Disable Prompt
git config --global mergetool.prompt false

Diff Tool
---------
Listing out Diff Tool
git config --global --get diff.tool

Configure a Diff Tool
git config --global diff.tool winmerge
git config --global difftool.winmerge.path "C:/Program Files (x86)/WinMerge/WinMergeU.exe"

Note : With respece to windows we use backslash for specifying file paths but here we need to use forward slash for configuring paths in GIT.

Disable Prompt
git config --global difftool.prompt false

Opens file in default editor
git config --global -e

Disable backups
git config --global mergetool.backup false


--------------------------------
+ Understand Comparison's in GIT
--------------------------------
To understand comparison's we have different scenario's. As a part of the tutorial we will first create a file in all the 4 stages or level in GIT such as
1. Working Area
2. Staged Area
3. Local repo
4. Remote repo

a)For this we create a file called README.md, add the following
--------------------------------------------------------------- 
# Starter Web Project
	
## Introduction

## Purpose

## Deployment

## How To Contribute

 - Add the file to GIT $ git add .
 - Commit the file $ git commit -m "Initial File"
 - Push the file $ git push origin master
Now we have added the file to remote. 
b)Modify the README.md and push
-------------------------------
# Starter Web Project
	This is a sample file for showing the git operations using command line.
## Introduction
	
## Purpose
	
## Deployment
	
## How To Contribute	
 - Do a Express Commit the file $ git commit -am "Added Description"
 - Push the file $ git push origin master

c)Modify the README.md
----------------------
# Starter Web Project
	This is a sample file for showing the git operations using command line.
## Introduction
	
## Purpose
	
## Deployment
	This activity is an automated process which will be done at 1:00am every day.
## How To Contribute	
 - Do a Express Commit the file $ git commit -am "Added Description"
 - Push the file $ git push origin master 
Now we have modified the file in the remote.

d)Modify the README.md and commit
---------------------------------
# Starter Web Project
	This is a sample file for showing the git operations using command line.
## Introduction
	This is a sample code to understand commands in GIT
## Purpose
	
## Deployment
	This activity is an automated process which will be done at 1:00am every day.
	
## How To Contribute
 - Do a Express Commit the file $ git commit -am "Added Introduction" 	
Now we have modified the file and commited. So the file is present in our local git repo.

e)Modify the README.md and commit
---------------------------------
# Starter Web Project
	This is a sample file for showing the git operations using command line.
## Introduction
	This is a sample code to understand commands in GIT
## Purpose
	
## Deployment
	This activity is an automated process which will be done at 1:00am every day.
	
## How To Contribute
	If you like the content don't forget to subscribe and like also don't forget to click the bell icon.
 - Do a Express Commit the file $ git commit -am "Added Purpose" Contribution to help.txt" 	
Now we have modified the file and commited. So the file is present in our local git repo.

f)Modify the README.md and add it but don't commit it
-----------------------------------------------------
# Starter Web Project
	This is a sample file for showing the git operations using command line.
## Introduction
	This is a sample code to understand commands in GIT
## Purpose
	Tutorial for comman layman to understand git and github. (Staged)
## Deployment
	This activity is an automated process which will be done at 1:00am every day.
	
## How To Contribute
	If you like the content don't forget to subscribe and like also don't forget to click the bell icon.
 - Now Add the file.	
Now we have modified the file added. So the file is present in our staging area.

g)Modify the README.md and dont add it don't commit it
------------------------------------------------------
# Starter Web Project
	This is a sample file for showing the git operations using command line.
## Introduction
	This is a sample code to understand commands in GIT
## Purpose
	Tutorial for comman layman to understand git and github. (Staged)
## Deployment
	This activity is an automated process which will be done at 1:00am every day.
	
## How To Contribute
	If you like the content don't forget to subscribe and like also don't forget to click the bell icon.
	
## Feedbacks
	Provide your feedbacks at githubtraining@git.com (Un-staged / Working directory)
 
Now we have modified the file but not yet added. So the file is present in our git's working area.

Comparison Exercise's
---------------------
1)Comparing Changes b/w unstaged and staged
--------------------------------------------
$ git diff
When we type the git diff all the files in the git's working area or unstaged area versus staged area are displayed. If there are three files in the unstaged area then all the 3 files will be listed.

Limiting comparison's to one file
---------------------------------
So In our example if i want to limit only the README.md file then i need to write
$ git diff -- README.md

The same can be viewed using WinMerge which is our default Git difftool
$ git difftool -- README.md
In this scenari the file will be opened in winmerge where we have one file from the local and another file from the actual repository path.


Note
/******************************/
git diff

Shows the changes between the working directory and the index. This shows what has been changed, but is not staged for a commit.

*git diff --cached
git diff --cached origin/branch1 (staged Vs remote)
git diff -R --cached origin/branch1 (remote Vs staged) -R option is to reverse the difference.

Shows the changes between the index and the HEAD (which is the last commit on this branch). This shows what has been added to the index and staged for a commit.

*git diff HEAD

Shows all the changes between the working directory and HEAD (which includes changes in the index). This shows all the changes since the last commit, whether or not they have been staged for commit or not.
/*********************************/


2)Comparison between commits
----------------------------
Now we have taken the README.md file as example

$ git log
xyz123 File Added
awer11 Description added
l3l3o3 Copyrite added
159822 removed spelling check


we can see the list of commit id's. Now if we want to compare 2 commits then
$ git diff reference1 reference2
$ git diff 1313o3 HEAD
where the pointer HEAD points to the last commit in the cureent branch.
Now if you press Enter you can see all the changes that have happened of several files from the last commit to the specified commit.

Alternative syntax.
-------------------
$ git diff HEAD HEAD^
This compares HEAD and HEAD - 1.

The same can be viewed using WinMerge which is our default Git difftool
$ git difftool HEAD HEAD^
i.e we can now visually see the difference between the last commit of the branch verses the commit just prior to the last commit in the branch.

Now i am taking 2 reference commits
$ git diff 159822 awerll
Now we can see the differneces b/w the one side and the other. There are cases where reference exists by dev/null which indicates the file has not exists prior and the other side the file exists.
For eg:
---------------------
--- /dev/null
+++ b/hipster.txt
---------------------
The above line indicates that the file is new.

The same can be viewed using WinMerge which is our default Git difftool
$ git difftool 159822 awerll
In difftool we can see only one file at a time, close the first then we can see the other.

3)Comparison between local and remote master branches
-----------------------------------------------------
Now we are going to compare between local repository branch and remote repository branch.
Syntax is
$ git diff rightsidecompare Vs leftsidecompare

$ git diff master origin/master
where origin is the name of the remote reference thats points to github and master is the branch on the git repository
  and master is the local repository which is pointing to head.
  
To view this visually
---------------------
git difftool master origin/master

-----------------------
+ Branching and Merging
-----------------------

1. Introduction
---------------
As of now we are doing all our changes in the master, which is not a best practice. What we should be doing is separating our changes into branches which makes sence. At the simplest level we should be atleast be creating a feature branches or topic branches to isolate our changes and then integrate them back to the master branch once this feature or topic is stabilized or completed.

To start of branches we will start with the listing of branch
Listing of Branches
-------------------
$ git branch
This will list down all the local branches on the m/c.

$ git branch -a
where -a list's both the local and remote branches, and the git branch command will put an asterisk(*) on the current active branch.
there is a color coding
	green -> current active
	red -> all remote branch
	gray -> locally repository branches available
	
Creating a new branch
---------------------
$ git branch branchName
where branchName is the name of the new branch
eg $ git branch mynewbranch

Now if i try listing the branch git branch -a, i can see the newly added branch mynewbranch added in the local repository.

Switch branches
---------------
To switch from one branch to another we use the git checkout command
$ git checkout branchName
here branchName is the name of the branch that you need to switch.
eg: git checkout mynewbranch
Now if you type git branch -a, you can see that the asterisk(*) is not moved to the new branch mynewbranch.

Alternative Approach
--------------------
Another way to creating a new branch and switching it to the newly added branch is by using the below command
$ git checkout -b branchName
where branchName is the name of the new branch
 -b helps us to branch or switch to the newly created branch.
Now you are in the newly created branch. Where as if you are not using -b then you will still be in the current branch you won't be switching to the newly created branch.
	
Now lets see how this is displayed in the history or logs
---------------------------------------------------------
$ git log --oneline --decorate
e060e24 (HEAD, origin/master, origin/HEAD, mynewbranch,master)
You will see something interesting here, the first commit which is our last commit has several labels associated with it. So we have HEAD which always points to the last commit on the current branch. origin/master, origin/HEAD, mynewbranch and master. So HEAD and origin/HEAD are simple pointers to the last commit on the respective branches both local and then remote. master is the branch which we are working with all along and the mynewbranch is the branch we just created.
Since we haven't made any changes yet all the branch labels are pointing to the same commit. Thats because branches are just labels or pointers. Our new branch wont actually branch off as we say until we have new commits that are unique from master. i.e the prompt updated with the newly created branch name.

Renaming a branch
-----------------
$ git branch -m mynewbranch newbranch
where -m is move.
Now we modified the branch name from mynewbranch to newbranch.
Now if we type git branch -a
We can see that mynewbranch is renamed to newbranch.

List All Branches From Remote
-----------------------------
git branch --remote
git branch -r

Delete a branch
---------------
If we no longer need a branch
$ git branch -d branchName
where branchName is the name of the branch that is to be deleted.
We cannot delete a branch in which we are currently on. you need to switch to another branch to delete it.
Now if we type git branch -a, we can see that our branch no longer exits.

Another Approach
----------------
If we try to delete the branch by giving the below command
$ git branch -d branchname
We may sometimes get an error as shown below
error: The branch 'ppd_common_feature' is not fully merged.
If you are sure you want to delete it, run 'git branch -D ppd_common_feature'.

Then we need to provide -D option

$ git branch -D branchname

eg
$ git branch -D ppd_common_feature
Deleted branch ppd_common_feature (was 2d7589e).

2. Fast Forward (Happy Path)
----------------------------
Now let's start some branching and merging examples.

1. go to the repository
2. type $ git branch -a
3. create a new branch title-change
$ git checkout -b title-change
4. modify the html file.
	Change Title
	Change Body
5. type git status and we can see the html file is modified.
6. do an express commit 
$ git commit -am "simple.html file changed"
7. check the log
$ git log --oneline
8. Perform Merging
We can see our commit at the top. So we have currently commited a change in the title-change branch and we need to move it into master.
First thing we need to do is 
a) Change back to master branch
$ git checkout master
Before i do a merge i need to know the differences are.
$ git diff master title-change
Now we can see the differences b/w the branch, if we need to see it visually then git difftool master title-change
Now after reviewing we do the merege
b) To do the merge we use the merge command
$ git merge title-change
Doing so git will respond to the merge 
	1.Updating 
	2.Hashes or commit id
	3.Fast-forward - It tells that the merge is a fastforwarded one
	4.simple.html - the files involved in the merge
	5.Status - deleted or inserted count.

Since this was a fast forwarded merge, effectively what just happened was Git just placed all the commits on the master branch as if we never branch away.
Fast forwarding is only really possible when there are no changes being made in the target branch, which is what we just did. We created a branch did some changes and we merged back. we didn't do any additional work in the master or target branch before doing the merge.

9. Now we view the log
$ git log --oneline --graph --decorate
Now we can see the HEAD is pointing to the lastest commit on the current branch. And the title-change and master is also pointing to the same commit as well. 
10. Delete the branch
Now if we list our branches 
$ git branch
Now we can see 2 branches master and title-change, since we have already merged the title-change to our master we no longer need it so to delete the branch we type the command
$ git branch -d title-change
Now if we type git branch we can see only the master branch.
11. Now we view the log
Now if we type git log
git log --oneline --graph --decorate
At the top commit we can see only the master branch. the title-change is removed.

3. Disable Fast forward Merge (Happy path without fast forward)
---------------------------------------------------------------
We need to be in a clear working directory. Once typeed 
git branch
we can see only the master branch.

1. Now lets us create a branch add-copyright
$ git checkout -b add-copyright
Now the branch has been created and we have switched into it.
If we type git branch 
we can see the newly created branch add-copyright and an asterisk against it.

2. Lets modify the file by adding a copyright details and the start and end of the html file.
Save the file.

3. Now check the status by
$ git status

4. Now we commit the file
$ git commit -am "Adding copy right information"

5. Now we also modify the README.md file
Save the file

6. Now we commit the file 
$ git commit -am "Adding copyright info to README.md file"
Now we have 2 files commited in the add-copyright branch.

7. Now if we check our logs
$ git log --oneline --decorate --graph
Now you can see the copyright information at the top. Press q to exit and lets integrate the changes to our master branch.

8. For that first switch to Master branch from add-copyright branch
$ git checkout master

9. For Merging the add-copyright branch to master type the code
Now this time i want to preserve the fact that we branched off so i am going to disable the fast forwarding capability by specifying the --no-ff option
	$ git merge add-copyright --no-ff
Now when we press enter its going to do a merge commit. So we end up with a commit message which the editor displays as 'Merge branch add-copyright'. So now we want to save and close.
We get the below message
Merge made by the 'recursive' strategy.
 index.html | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

10. Now we check the log
$ git log --oneline --decorate --graph
Now if we look at the logs we can see the graph line being preserved.
11. Delete the brach
Now we have integrated the changes now we can get rid of the branch
$ git branch -d add-copyright

12. Now if we view the log
$ git log --oneline --graph --decorate
we can see that the we don't have the label's or branch-name associated when we branch off. i.e the branching still occurs but we don't have a label associated that's all.

4. Automatic Merges
-------------------
So Now we have covered how to create a branch, do some work on it and merge it into master. But in the happy path scenario where the result is a fast forward merge, even going as far as to disable the fast forward merge scenario but we still have that condition present. So the next step is to go through the process but this time there will be an automatic merge and result in a merge commit automatically.

We need to be in a clear working directory. Once typeed 
git branch
we can see only the master branch.
1. Now lets us create a branch simple-changes
$ git checkout -b simple-changes
Now the branch has been created and we have switched into it.
If we type git branch 
we can see the newly created branch add-copyright and an asterisk against it.

2.Now lets edit first file that is independent of each other.
 - make changes for file1
 git status we can see file1 is modified.

3. Commit the file
 git commit -am "File Modified 1 in simple-changes branch"

4.Now lets edit second file that is independent of each other.
 - make changes for file2
 git status we can see file1 is modified.

5. Commit the file
 git commit -am "File Modified 2 in simple-changes branch"

6. For that first switch to Master branch from add-copyright branch
$ git checkout master 

7. Before merging the changes in i am going to make change to a file in the master. This could be done by another developer or you can do the change by context switching (branch switching) so lets update the README.md file (Note that you should change a file which you have not updated in the simple-changes branch....)
Save the file and type git status, we have one modified file.

8.Now the commit the file in master branch
$ git commit -am "Commiting file info master branch"

9. Now if we view the log
$ git log --oneline --decorate --graph
You can see an interesting thing in the top of the log, we have a commit on the simple changes that is different and we have a commit on the master.

10. Now Merge the code from simple-changes to master
So from master, we do the merge
$ git merge simple-changes -m "Merging changes from simple-changes to master"
 where -m is the message.
Since we know that this merge results in a commit so in quotes we give the commit message.
Then you get the below text as response from git
Merge made by the 'recursive' strategy.
 help.txt   | 2 ++
 index.html | 4 ++--
 2 files changed, 4 insertions(+), 2 deletions(-)

11 Repeat the git log command
$ git log --oneline --decorate --graph --all
So if you notice the top log, so we can see that when the merge happended. that we have the merge commit and the simple-changes is still preserved as a separate branch. 

12. Now we have integrated the changes now we can get rid of the branch
$ git branch -d simple-changes

13. Now if we view the log
$ git log --oneline --graph --decorate
we can see that the we don't have the label's or branch-name associated when we branch off. i.e the branching still occurs but we don't have a label associated that's all.

14. Now we check and ensure that our file changes are present.

5. Conflicting Merges and Resolution
------------------------------------
Now we will understand and resolve merge confilicts.
Most of the times you will be doing a fast forward merge or merges that could result in fast forward or GIT is going to resolve the merges automatically. However sometimes you are going to run into conflicts and you are going to need to resolve them. lets see with an example.

We need to be in a clear working directory. Once typeed 
git branch
we can see only the master branch.

Now we are going to modify the simple.html file on one branch switch back to master and do similar change in the same file simple.html and that too in the same area's. So that it will result in a conflict. 

Perhaps this can occur if two different developers working on different branches and they have to come together and there changes are not yet compatable. Somebody has to sit and work down the issues.

1. Now lets us create a branch real-work
$ git checkout -b real-work
Now the branch has been created and we have switched into it.
If we type git branch 
we can see the newly created branch real-work and an asterisk against it.

2.Now lets edit the simple.html file
 	- body of the page
	- footer
	- title
	- paragraph
and save.
Now if we type git status we can see that simple.html is now modified.
3. Commit the file
$ git commit -am "Making changes to simple.html in real-work branch"
if we type git status we have a clean working directory.

4. Now we switch to master
$ git checkout master

5. Now we edit the same file simple.html, Now lets create some changes for conflicting with the other branch.
 	- body of the page
	- footer
	- title
	- paragraph
and save.
Now if we type git status we can see that simple.html is now modified.

6. Now the commit the file in master branch
$ git add simple.html
$ git commit
Now it invokes the editor and i type in the message  "Commiting file info master branch"

7. View the logs
$ git log --oneline --decorate --graph --allows
Now git shows that our work is diverged we have real-work and master with different changes. 

8. Compare the files in both the branch using difftool or diff
$ git diff master real-work 
Now when we compare we can view the changes in the same line hence we can assure that conflict occurs.
To view the changes visually
$ git difftool master real-work
And we can visually inspect the changes between the two branches.

9. Now Merge the code from real-work to master
So from master, we do the merge
$ git merge real-work
When we press enter we get a merge conflict error the branch name changes from master to master|MERGING
Following are the output results that git displays as a part of merge
1. Auto-merging simple.html
	GIT first tried to do a auto-merge
2. CONFLICT (content): Merge conflict in simple.html
	GIT couldn't do the auto-merging so it resulted in a conflict in the content.
3. Automatic merge failed : fix conflict and the commit the result
	So Automatic merge Failed, so now we have to fix the conflict's 
4. (merge|MERGING)
	So we are merging against the master so we are in a MERGING state or neither in a clean working directory or in a staged area or in between state of merging.
10. Open the conflicted file simple.html and manually merge the changes
We can see some extra tags such as HEAD and real-work which is the branch name. This is nothing but Git will markup or show up or highlight the differences. So in simple.html the difference's are marked as follows
/****************************************************************************************/	
A. Difference at Area 1
<<<<<<< HEAD
	<title>A Very Respectful Website</title>
=======	
	<title>A Great Website</title>
>>>>>>> real-work

B. Difference at Area 2
	<p>
<<<<<<< HEAD
	I'm not sure what will go here but i am sure it will be nice
	</p>
  </main>
  <footer class="container">
	<p>&copy; 2002 github.com</p>
=======
	Some interesting stuff goes here
	</p>
  </main>
  <footer class="container">
	<p>@copy; 2020 github.com</p> 
>>>>>>> real-work

C. Difference at Area 3



/****************************************************************************************/
So if we look at the first difference 

<<<<<<< HEAD
	<title>A Very Respectful Website</title>
=======		
Here HEAD is referencing to the target branch which is master, because we did a merge from the target branch which is our master branch. Here the contents are of simple.html present in master branch.

and 

=======	
	<title>A Great Website</title>
>>>>>>> real-work
Here real-work is the new branch and the contents are of the simple.html presetn in real-work branch.	

If the changes are simple then we can modify the files manullay merge the conflict and proceed.

11. Open the conflicted file simple.html using mergetool and manually merge the changes
Open the mergetool which we configured by providing the comman
$ git mergetool
This opens the file in diffmerge and merge it manually.

There are 3 files now out of which 3 are created by git and one is our main simple.html file in which we should resolve the conflict.
1) ./simple.html.REMOTE.4937.html
2) ./simple.html.BASE.4937.html
3) ./simple.html.LOCAL.4937.html

Now where we have to manually pick and choose the respective content. Once done save and close the file.

12. Check the status.
Before merging the changes our brnach or prompt is in the (master|MERGING) state. So if we type
$ git status
	- The branch is master and its in the merging state (master|MERGING)
	- We can see that the simple.html is modified and its in ready to be staged state.

13. Commit the merged File simple.html
Till now the status of the branch or prompt is (master|MERGING) and we have manually merged the file and now we need to do a commit. For that type the commit command
$ git commit -m "Done resolving merge conflict"
Once i have done the commit my prompt or branch stage has changed from (master|MERGING) to (master), which means i am out of the merge conflict.

Note if i do a git status i can see one un-tracked file named simple.html.orig and thats because resolving the merge git will save of an original copy of the merge conflicts so that something got lost we can revert the changes. However i don't want to track the *.orig files so that we can go and add it in the .gitignore list now if we do a git status we can no longer see the *.orig file. Now we commit the .gitignore file.

14. Delete the real-work branch
Now we have integrated the changes now we can get rid of the branch
$ git branch -d real-work

15 View the Log
$ git log --oneline --decorate --graph --all
I can see that i have done resolving merge conflicts, which is a merge commit. followed by the latest commit which i did for commiting .gitignore file to exclude the *.orig files.

-----------
+ Rebasing
-----------

1. Simple Rebase Example
------------------------
In order to understand the concept of rebasing. We have to do some steps.
1. From the master bracnch creature a feature branch.
2. And in the feature branch do some work atleast 3 commits.
3. Later on switch back to master and do some work atleast 3 commits.
4. And rebase my changes back to the feature branch.

So consider we have a master branch 'rebase-master' and feature branch called 'rebase-test'
1. We switch to 'rebase-test' 
$ git checkout rebase-test.
2. We add server.port in application.properties file 
## Added Server Port 
#server.port=8009
3. Then we do a express commit
$ git commit -am "server.port added to application.properties"
4. We again add logging.file in application.properties
## Added Log File
#logging.file=springbootdemo.log
5. Then we do a express commit
$ git commit -am "logging.file added to application.properties"
6. Now we switch to master branch
$ git checkout rebase-master
7. Now we will modifiy the pom.xml by adding some comments
Add the comment for maven-plugin
<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-maven-plugin -->
8. Then do a express commit
$ git commit -am "Comment added for maven-plugin in pom.xml"
8. Now again we will modifiy the pom.xml by adding another comments
Add the comment for springboot-web
<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web -->
9. Then do a express commit
$ git commit -am "Comment added for springboot-starter-web in pom.xml"
10.Let take a look at our history
$ git log --oneline --decorate --all --graph
/********************************************************************************************/
* 536dfa5 (HEAD -> master-rebase) comment added for springboot-starter-web in pom.xml
* e6f3f9c comment's added for maven-plugin in pom.xml
| * 5a3cc62 (rebase-test) logging.file configuration added in application.properties
| * b5e9d0e server.port configuration added in application.properties
/********************************************************************************************/
Now you can see in the above, o/p you can see the master-rebase and rebase-test they are in separate lines and you can see the graph line diverging. So in a rebasing scenario i am not done with my feature but i want to incorporate any changes that may have happened on master. so i will have a massive headache when i do merge later. so to do that i can use rebase. So i want to rebase master (master-rebase) into my feature branch (rebase-test). 
11. So i am returning to feature branch 
$ git checkout rebase-test
Now that i am in rebase-test feature branch lets rebase in any changes that we have made on the master branch and then lets see how it has effected our history.
12. Git Rebase Command
lets use the git rebase command and on the branch in which you want to do a rebase into we type
syntax : git rebase source-branch
eg: git rebase feature
$ git rebase master-rebase
/********************************************************************************************/
First, rewinding head to replay your work on top of it...
Applying: server.port configuration added in application.properties
Applying: logging.file configuration added in application.properties
/********************************************************************************************/
So the rebase command is saying its rewinding our head which is our current branch so that we can reapply any changes we have made on top of what every has happened on master.
So finally what every changes in master i.e changes in the pom.xml will be taken and then our changes related to application.properties will be addded on top of it. Hence its says first rewinding head to replay your work on top of it.
13.Let take a look at our history
$ git log --oneline --all --decorate --graph
/********************************************************************************************/
* 496b09d (HEAD -> rebase-test) logging.file configuration added in application.properties
* 158b30e server.port configuration added in application.properties
* 536dfa5 (master-rebase) comment added for springboot-starter-web in pom.xml
* e6f3f9c comment's added for maven-plugin in pom.xml
| * baa6a97 (origin/master, master) modified source
/********************************************************************************************/
Now you can see now we have the master applied first then our feature is applied.
In order for this to happen from our branch i.e 'rebase-test' we had to rewind the changes what has happened (application.properites) and then add or playback the changes on master-rebase (pom.xml) on the 'rebase-test'. And then apply the changes on the 'rebase-test' branch. In doing so it flattened my history. And it also allow us to do a fast forward merge once we have done changes on our feature.
14.Now from the feature branch 'rebase-test' we will modify pom.xml
Add the comment for springboot-jpa
<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-jpa -->
15. Then do a express commit
$ git commit -am "Comment added for springboot-starter-jpa in pom.xml"
16.Let take a look at our history
$ git log --oneline --decorate --all --graph
/********************************************************************************************/
* b164978 (HEAD -> rebase-test) Comment added for springboot-starter-jpa in pom.xml
* 496b09d logging.file configuration added in application.properties
* 158b30e server.port configuration added in application.properties
* 536dfa5 (master-rebase) comment added for springboot-starter-web in pom.xml
* e6f3f9c comment's added for maven-plugin in pom.xml
/********************************************************************************************/
Now if you see the recent commit has moved up one level. Now the last commit is at the top.
Now i am done with the feature branch lets merge the feature with our master
16. Merging feature branch 'rebase-test' to 'master-rebase'
$ git checkout master-rebase
$ git merge rebase-test
17. Now view the logs
$ git log --oneline --decorate --graph --all
/********************************************************************************************/
* b164978 (HEAD -> master-rebase, rebase-test) Comment added for springboot-starter-jpa in pom.xml
* 496b09d logging.file configuration added in application.properties
* 158b30e server.port configuration added in application.properties
* 536dfa5 comment added for springboot-starter-web in pom.xml
* e6f3f9c comment's added for maven-plugin in pom.xml
/********************************************************************************************/
Now we can see both the master-rebase and rebase-test point to the same commit id.
18. Delete the rebase-test branch
Now we have integrated the changes now we can get rid of the branch
$ git branch -d rebase-test

2. Setup for rebasing conflicts
-------------------------------
For this exercise we have created 2 branches
a) master-rebase (master)
b) rebase-conflict (feature)

1. Modify pom.xml in master
Add the message in pom.xml above dependencies tag
<!-- Adding Changes to rebase-master before rebase conflicts -->

2. Then we do a express commit
$ git commit -am "Adding Message in pom.xml Before Rebase Conflicts"

3. Now we switch on to feature branch rebase-conflict
$ git checkout rebase-conflict

4. Now we have to do some conflicting changes
Open pom.xml and modify the following tags description, version and scope.
save.

5. Then we do a express commit
$ git commit -am "Modified pom.xml for conflicts"

6. Now we switch on to master branch
$ git checkout master-rebase.

7. Now we will make some changes on the same file pom.xml so that we will get a conflict.
Open pom.xml and modify the following tags description, version and scope.
save.

8. Then we do a express commit
$ git commit -am "Modifed pom.xml for conflicts"

9. We check the logs
$ git log --oneline --all --graph --decorate
/********************************************************************************************/
* de3926f (HEAD -> master-rebase) Modifed pom.xml for conflicts in master-branch
* af753d3 Adding Message in pom.xml Before Rebase Conflicts
| * 92f0c76 (rebase-conflict) Modified pom.xml for conflicts
/********************************************************************************************/
Now on the top we have 2 commits one on each branches. Here we have master-rebase and rebase-conflict which are diverged.
Also we have now completed the setup of raising a conflict.

3. Abort a Rebase.
------------------
We have setup a conflict situation for our pom.xml in master-rebase and rebase-conflict branches.
1. Switch to feature branch
$ git checkout rebase-conflict

2. View difference in pom.xml b/w master-rebase and rebase-conflict
$ git difftool first-branch second-branch
$ git difftool master-rebase rebase-conflict
We have seen that there are many places or lines which will result in a conflict.

3. Now we will try to rebase our master 'master-rebase'
$ git rebase master-rebase
/********************************************************************************************/
First, rewinding head to replay your work on top of it...
Applying: Modified pom.xml for conflicts
Using index info to reconstruct a base tree...
M       pom.xml
Falling back to patching base and 3-way merge...
Auto-merging pom.xml
CONFLICT (content): Merge conflict in pom.xml
error: Failed to merge in the changes.
Patch failed at 0001 Modified pom.xml for conflicts
Use 'git am --show-current-patch' to see the failed patch

Resolve all conflicts manually, mark them as resolved with
"git add/rm <conflicted_files>", then run "git rebase --continue".
You can instead skip this commit: run "git rebase --skip".
To abort and get back to the state before "git rebase", run "git rebase --abort".
/********************************************************************************************/
From this point we have to perform manually. We have different alternatives.
a) To abort rebase : We can abort rebase by typing the command $ git rebase --abort
b) To resolve manully
Manually resolve the file pom.xml and add the file and commit. then do continue the rebase operation by typing the command $ git rebase --continue
c) To skit the commit : you can remove your commit and proceed with a rebase by typing the command $ git rebase --skip

4. Abort Rebase 
As expected the rebase resulted in a conflict so for this we can abort a rebase we type the command
$ git rebase --abort

5.Now check the log
$ git log --oneline --all --graph --decorate
* de3926f (master-rebase) Modifed pom.xml for conflicts in master-branch
* af753d3 Adding Message in pom.xml Before Rebase Conflicts
| * 92f0c76 (HEAD -> rebase-conflict) Modified pom.xml for conflicts
We can see nothing is changes, we can see the 2 branches are diverged.

4. Rebase Conflict and Resolution
---------------------------------
In order to resolve the conflict we need to swith to rebase-conflict branch
$ git checkout rebase-conflict

1. View the history
$ git log --oneline --all --graph --decorate
* de3926f (master-rebase) Modifed pom.xml for conflicts in master-branch
* af753d3 Adding Message in pom.xml Before Rebase Conflicts
| * 92f0c76 (HEAD -> rebase-conflict) Modified pom.xml for conflicts
We can see nothing is changes, we can see the 2 branches are diverged.

2.Now do a rebase
$ git rebase master-rebase
/********************************************************************************************/
First, rewinding head to replay your work on top of it...
Applying: Modified pom.xml for conflicts
Using index info to reconstruct a base tree...
M       pom.xml
Falling back to patching base and 3-way merge...
Auto-merging pom.xml
CONFLICT (content): Merge conflict in pom.xml
error: Failed to merge in the changes.
Patch failed at 0001 Modified pom.xml for conflicts
Use 'git am --show-current-patch' to see the failed patch

Resolve all conflicts manually, mark them as resolved with
"git add/rm <conflicted_files>", then run "git rebase --continue".
You can instead skip this commit: run "git rebase --skip".
To abort and get back to the state before "git rebase", run "git rebase --abort".
/********************************************************************************************/
as expected you will get the conflict now we are in a conflicting state during a rebase. we can consider this as a merge-conflict and resolve the conflicts manually and proceed.

3.Now open visual tool and merge the code
git mergetool
manually merge and save the file.

4.Check the status
$ git status
Now we can see the file which we manually resolved the conflict. And its in modified stage and ready to
Note : You can see the file is ready to commit, but don't do an express commit in this stage. Always add the file first whenever there is a conflict.

5. Add the manually resolved file.
$ git add <modified_file>

6. Now proceed with rebase
$ git rebase --continue
Now we have resolved the rebase conflict and our stage has been changed from rebase conflict to branch active state.

7. View the history
$ git log --oneline --all --graph --decorate
/********************************************************************************************/
* 8037714 (HEAD -> rebase-conflict) Modified pom.xml for conflicts
* 9a21424 Conflicts Resolved for pom.xml during rebase
* de3926f (master-rebase) Modifed pom.xml for conflicts in master-branch
* af753d3 Adding Message in pom.xml Before Rebase Conflicts
* baa6a97 (origin/master, master) modified source
/********************************************************************************************/
Now that we can see that we have aplied our master commit. and then our feature branch commit.	

8. Now we change the pom.xml file again
Save and check the status $ git status

9. Do Express commit
$ git commit -am "Commiting code after rebase conflict"

10. View the history
$ git log --oneline --all --graph --decorate
/********************************************************************************************/
* 8f1875d (HEAD -> rebase-conflict) Commiting code after rebase conflict
* 8037714 Modified pom.xml for conflicts
* 9a21424 Conflicts Resolved for pom.xml during rebase
* de3926f (master-rebase) Modifed pom.xml for conflicts in master-branch
/********************************************************************************************/
Now we can see that our latest commit has come at the top.

11. Now we are done with our changes let merge it to our master branch
$ git checkout master-rebase
$ git merge rebase-conflict

12. View the history
$ git log --oneline --graph --all --decorate
* 8f1875d (HEAD -> master-rebase, rebase-conflict) Commiting code after rebase conflict
* 8037714 Modified pom.xml for conflicts
* 9a21424 Conflicts Resolved for pom.xml during rebase
Now we can see that both the master-rebase, rebase-conflict branch point to the same commit.


4. Pull with Rebase (How to Rebase Incomming changes from github on to your local repository)
---------------------------------------------------------------------------------------------
In this example i want to show some incoming changes from github on to our local repository.

For this example we create a branch rebase-pull
$ git branch rebase-pull
$ git checkout rebase-pull
1. Modify the file pom.xml
Save
2. Express Commit pom.xml
$ git commit -am "local : Changes to pom.xml"

3. Go to browser github select the branch and modify pom.xml
Save

4. Commit the file and give the message "remote: simple changes to pom.xml from browser"

5. Now in gitbash check the status
$ git status

6. Update the reference on the local from the remote repository by giving fetch command
$ git fetch origin rebase-pull

7. Now check the status
$ git status
Now we can see that your branch and the 'origin/rebase-master' have diverged and have 1 and 1 different commit each.

8. Now we do a rebase
Now lets say i want to continue working i am not ready to merge like a traditional merge.
So what i need is i rather put my commit or my changes ahead of what ever is there on github (rebase-pull branch). But i want the benefit of any changes that may have occured in github. so for that we can issue the git pull command by passing in an extra parameter because of rebase during the process.

$ git pull --rebase origin rebase-pull
So this is our standard command, except that now we are using the --rebase option because of rebase instead of normal merge.
Press Enter, now we have rebased our changes from github on top of our master branch on our local repository. 

9. Now check the status
$ git status
Now we can see that our branch is simply ahead of 'origin/rebase-pull' by one commit.

10. View the history
$ git log --oneline --all --graph --decorate
So we can see our origin/rebase-pull and our rebase-pull branch, the local rebase-pull branch is on top on origin/rebase-pull.

-----------
+ Stashing (stash)
-----------
In this session we will look upon various scenarios to execute a stash.

1. Simple Stash Example
-----------------------
Create a branch called 'master-stash' and 'stash-test'

1. Switch on to master-stash branch
Modify the pom.xml and Save.

2. Now check the status
$ git status
We can see that the pom.xml is modified. However the pom.xml in my case is going to be a work-in-progress i am not ready to commit the file in this state. However i need to change my gears and modify a different file for something that has to get right now. In order to save the changes that i have for pom.xml i can use git stash command to shash away any changes that are work-in-progress. So that i can change gears and work-on something else.

3. Save the Work-In-Progress File using Stash command
$ git stash
or $ git stash save
When we type git stash by default it will execute the save command. 
When i pressed Enter i got the below message
Saved working directory and index state WIP on master-stash: baa6a97 modified source

4. Now check the status
$ git status
Now we can see that we are in a clean working directory. There are no files in the staging area for commit or anything that is in the staging area. So if i open my pom.xml i can see that its the same file. and i am not able to see my recent changes.

5. Add changes to application.properties
Well lets go and do some changes i open the application.properties file and add the server.port=8009
Save

6. Now check the status
$ git status
Now you can see that the application.properties is modified.

7. Commit the file
Now we do an express commit
$ git commit -am "master : Changes to application.properties in master-stash branch"

8. Now check the status
$ git status
Now we can see that we are in a clean working directory.

9. Fetching or Retrieving the stashed Work-In-Progress File
Now how do we retrieve the stashed file, now that i have completed the high priority task i want to resume my work where i stopped. so how do i retrieve my saved file.
So for this we need to apply our stash, type the command
$ git stash apply
Now lets review the changes, the git stash apply will then give us a git status basically on our working directory which applies what action that the git stash apply command has to do. In this case it put back the pom.xml file into its original stage which is in the working directory changes. Git status also gives us the same information.
Now lets open and verify the pom.xml file. We can see that the discription is back to the was it (<description>From Master. Understanding Stashing Example</description>) before issueing a git stash command. Now we can continue our work from this point onwards. do the necessary changes and save

8. Now check the status
$ git status
Now we can see the modified file pom.xml

9. Commit the changes
Let do an express commit 
$ git commit -am "In Master modifying pom.xml"
Now we are done with our commits.

10. Now check the status
$ git status
Now we can see that we are in a clean working directory.

Save Command
------------
Saves the file
$ git stash save, the save command is optional we can also type git stash

Stash the file with a stash message
-----------------------------------
However to stash before we used the command
the git stash command is fine if you are doing only one stash at a time. But in this case i actually want to specify a stash message so this one is going to be like a commit message, but for a stash. This will make us easier to differentiate between different stashes.
$ git stash save "simple changes for pom.xml"
Now we have created a stash with the stash message "simple changes for pom.xml"

List Command
------------
Now lets look at the list subcommand of stash
$ git stash list : list's all the stashes
stash@{0}: WIP on master-stash: baa6a97 modified source

We have a single item 'stash@{0}:' which is referenced at 0 where we start off with any list. 
'WIP' indicated its Work-In-Progress
and the master-stash is the branch with the reference Id 'baa6197'
and next is the commit message.
Since we have already applied the stash we do not need it anymore, which means we can drop the stash

Drop a stash
------------
To drop a stash type the command
$ git stash drop
Dropped refs/stash@{0} (ed493b4498d5df52d64f8264d31af797c1c07cf1)
And that would drop the last stash.

Droping a specific stash reference
----------------------------------
In order to drop a specific stash reference we use the command git stash drop stash_reference.
$ git stash drop stash@{1}

Delete all the stashes from the stash list
------------------------------------------
There might be a situation we need to delete or clear all the stashes from the stash list then we use the clear command.
$ git stash clear

eg: 
$ git stash list
stash@{0}: On master-stash: simple changes for SpringbootDemoApplication.java
stash@{1}: On master-stash: application.properties changes
stash@{2}: On master-stash: simple changes for pom.xml

$ git stash clear
This will empty all the stashes in the list.

Picking our a specific stash
----------------------------
For picking up a specific stash we use the command git stash show reflog_syntax
where reflog syntax allows us to reference the specific stash to show and that would be "stash" and then "@" symbol and then, in curly braces, the stash index you wish to look at, in this case i am going to use "1".
eg : $ git stash show stash@{1}
$ git stash show stash@{1}
 src/main/resources/application.properties | 5 ++++-
And then in comes back and tells us that application.properties is a part of that stash.

Applying stash to a new branch
------------------------------
Firstly we have to perform a stash
$ git stash save "sample-aws-secret-manager"
Now lets go and apply stash to a new branch. And in order do so we have the below syntax
	$ git stash branch branchName
		where branchName is the name of the branch
And to do that we are going to issue the command 
$ git stash branch branch-stash-test
no changes added to commit (use "git add" and/or "git commit -a")
Dropped refs/stash@{0} (51c117c841c5a7a04466305ef64cbd6c900a583c)

As now you will be moved to the new branch branchName and the stash reference is deleted.

2. Stashing Untracked files and Using Pop
-----------------------------------------
By default stash command will only stash tracked files.

$ git ls-files - tracks all the files that GIT is monitoring

$ git ls-files
.gitignore
.mvn/wrapper/MavenWrapperDownloader.java
.mvn/wrapper/maven-wrapper.jar
.mvn/wrapper/maven-wrapper.properties
mvnw
mvnw.cmd
pom.xml
src/main/java/com/xyz/spring/raul/SpringbootDemoApplication.java
src/main/resources/application.properties
src/main/resources/banner.txt
src/test/java/com/xyz/spring/raul/SpringbootDemoApplicationTests.java

1.So we open our pom.xml
Modify the pom file by including some comments like <!-- Springboot Web Dependency -->	& <!-- Springboot JPA Dependency -->
Save the file.

2.We check the status
$ git status
We can see that we have the "Changes not staged for commit" This is the status that is given to working directory changes for files that are been tracked by git. However if i decide to add a new file.

3.Adding a new file
$ npp newFile.txt

4.We check the status
$ git status
Now if you check the status, we have a slightly different status for new files; these are files that Git is not tracking yet. So if i do a "git stash" git stash will only get the modified file which is pom.xml

5.Do a Git Stash
$ git stash
Saved working directory and index state WIP on master-stash: baa6a97 modified source
to verify this we  check the status

6.We check the status
$ git status
On branch master-stash
Untracked files:
  (use "git add <file>..." to include in what will be committed)

        newFile.txt

nothing added to commit but untracked files present (use "git add" to track)

We still have the untracked file. which means our working directory is not clean. So i am going to re-apply.

For that we first pop the stashed file so that we can have both the tracked and untracked file. so for that we do a git stash apply
$ git stash apply.

Secondly we delete the value in the stack git stash drop
$ git stash drop

Finally we verify we don't have any stashed files by the list attribute
$ git stash list
now we can see that we don't have any stashes pending.

If we check the status
$ git status
On branch master-stash
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   pom.xml

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        newFile.txt

no changes added to commit (use "git add" and/or "git commit -a")

7.Stashing an untracked file.
To stash an untracked file we have couple of options, we could simply add the new file to the Git Staging Area. So once that occurs Git will start tracking the file. However if you are not sure if you want to add that file, but you still want to stash it so you can determine that later, then we have an extra parameter for the git stash command. 
Well let's do that now so we just do a git stash -u
$ git stash -u
eg : git stash save -u "Moving WIP files of main-fmipv"
Then git stash command will then include any untracked files. that are not being excluded by .gitignore. Now if we do a git status

8.We check the status
$ git status
Now we have a clean working directory.

9.Verify the stashes
$ git stash list
stash@{0}: WIP on master-stash: baa6a97 modified source
We can see we have one stash file.

10.Modify the application.properties files
we add the
## Doing an emergency fix after our stash.
server.port=8088
Save the file.

11.Now commit the application.properties
$ git commit -am "Adding Fix after doing stashing files"

12.Verify the status
$ git status
Now we have a clean working directory.

13.Applying the changes from stash
After we have done our emergency fix, Now lets go ahead and apply our changes that we have in our stash. However this time i am going to show you an express way of doing that. Earlier we have to do two commands
a) $ git stash apply
b) $ git stash drop
Now if we want to apply and drop the last stash in the list of stashes so now we can do that in one command 
$ git stash pop
For people who are coming from a programming background this is like popping the stack.
$ git stash pop
On branch master-stash
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   pom.xml

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        newFile.txt

no changes added to commit (use "git add" and/or "git commit -a")
Dropped refs/stash@{0} (a29afbbce926d2c53d7cfb96ae51d5466f64a868)

Now we have the modified file pom.xml and our untracked file newFile.txt back in our working directory. Now if you see the console message "Dropped refs/stash@{0} (a29afbbce926d2c53d7cfb96ae51d5466f64a868)" means we have droped the stash too.

14.Verify the status
$ git status
Now we have both the modified file and the untracked file in the working directory.

15.Deleting the untracked file.
We are not interested in the new file, so we are deleting it.
$ rm newFile.txt

16.Verifying the status
$ git status
Now we can see only the modified pom.xml file.

17.Commit the file.
We do an express commit.
$ git commit -am "Commiting the file after doing a git stash pop command."

18.Verifying the status
$ git status
Now we have a clean working directory.


3. Managing Multiple Stashes
----------------------------
I am in a clean working directory master-stash branch. Now lets work with multiple stashes by modifying couple of files from the working directory.

1.Modify pom.xml
Modify pom.xml by providing the comment for jpa and web.
Save.

If we do a git status
$ git status
On branch master-stash
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   pom.xml

no changes added to commit (use "git add" and/or "git commit -a")


2.Stash the file.
However to stash before we used the command
$ git stash 
the git stash command is fine if you are doing only one stash at a time. But in this case i actually want to specify a stash message so this one is going to be like a commit message, but for a stash. This will make us easier to differentiate between different stashes.
$ git stash save "simple changes for pom.xml"
Now we have created our first stash.

3.Modify application.properties
Modify applcation.properties by adding 
server.port=8099
Save.

4.Stash the file.
$ git stash save "simple changes for application.properties"
Now we have created our second stash.

5. Modify SpringbootDemoApplication.java
Provide a line in our main method()
eg. System.out.println("Multiple Stashing Example for Git");

6.Stash the file.
$ git stash save "simple changes for SpringbootDemoApplication.java"
Now we have created our third stash.

7.List all stashes
In order to list all the stashes we use the command
$ git stash list
stash@{0}: On master-stash: simple changes for SpringbootDemoApplication.java
stash@{1}: On master-stash: application.properties changes
stash@{2}: On master-stash: simple changes for pom.xml

Now you can see that the stash index is probably the reverse of what you are expecting; that the last stash in index "{0}". Now the index "{0}" may be a thing that's throwing you off as well but that comes from a programming background, where the indexs of the list or arry start with index 0. But the point to note here is the last stash is index 0 not 2. 

8.Picking our a specific stash and displaying the files.
For picking up a specific stash we use the command git stash show reflog_syntax
where reflog syntax allows us to reference the specific stash to show and that would be "stash" and then "@" symbol and then, in curly braces, the stash index you wish to look at, in this case i am going to use "1".
eg : $ git log show stash@{1}
$ git stash show stash@{1}
 src/main/resources/application.properties | 5 ++++-
And then in comes back and tells us that application.properties is a part of that stash.

9.Verify the status
If we type $ git status we can see that we have a clean working directory.
$ git status

10.Reapply stash
Now we will reapply one of the stashes. So unlike other commands, we can specify the specific stash we want to apply with our "git stash apply" command. So currently we have a clean working directory and we can reapply the stash by the command
Say we need to apply the middle stash. so for this first we list out the all the stashes
$ git stash list
stash@{0}: On master-stash: simple changes for SpringbootDemoApplication.java
stash@{1}: On master-stash: application.properties changes
stash@{2}: On master-stash: simple changes for pom.xml
Now i want to apply the application.properties changes to my working directory
For that i use the command git stash apply and then the stash reference "stash@{1}"
$ git stash apply stash@{1}
On branch master-stash
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   src/main/resources/application.properties

no changes added to commit (use "git add" and/or "git commit -a")

Now git stash will apply the specific changes that's captured in the stash. So now we have our modified application.properites file.


11.Verify the status
$ git status
git status tells us that we have our modified "application.properites" file which is the same output from git stash apply command. Like the other commands we have covered the drop command will also take the stash reference. 
so lets do a git stash list to see our list of stashes

$ git stash list
stash@{0}: On master-stash: simple changes for SpringbootDemoApplication.java
stash@{1}: On master-stash: application.properties changes
stash@{2}: On master-stash: simple changes for pom.xml

And now we have applied the stash reference{1} which is the application.properties changes. I dont need them anymore so i am going to drop them. 

12.Droping stash reference of index 1
In order to drop a specific stash reference we use the command git stash drop stash_reference.
$ git stash drop stash@{1}
Dropped stash@{1} (2c73fcfa0857123550489171c1721f94067570a1)
The stash has been droped. Now if we use the list command

13.Listing all stashes
$ git stash list
stash@{0}: On master-stash: simple changes for SpringbootDemoApplication.java
stash@{1}: On master-stash: simple changes for pom.xml

We can see the stash with application.properties changes is not longer there; its no longer listed in our list of stashes. Also what's interesting is that the next stash available has gone in to populate the stashes at {1}, which is simple changes.

14.Delete remaining stashes
So next let's just say that the rest of the stashes I no longer need, for what ever reason. so i use the git stash clear command.
$ git stash clear

15.Listing all stashes
$ git stash list
Now we can see that the list is empty we have no results.


4.Stashing into a branch
-------------------------
We have seen how to stash a file or files to a stash list. In this example we are going to see how can we stash the files to a branch.

1.Modify pom.xml, application.properites and SpringbootDemoApplication.java.
Make a small tweeks in the above 3 files.

- Modify pom.xml
Modify pom.xml by providing the comment for jpa and web.
Save

- Modify application.properties
server.port=8099
Save

- Modify SpringbootDemoApplication.java
System.out.println("Multiple Stashing Example for Git");
Save

2.Verify the status
$ git status 
Now as you can see that i have 3 modified files.

3.Add one file to staging area
So lets add pom.xml to staging area
$ git add pom.xml

4.Verify the status
$ git status 
We have pom.xml in the changes to be commited state which is in the staging area, and the rest are just not staged for commit; basically the modified files is in the working directory.

5.Adding a new file
Just for our complete demo we will add a new file.
$ npp newFile.txt
and we wrote New Contents as text.
Save.

6.Verify the status
$ git status
On branch stash-master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        modified:   pom.xml

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   src/main/java/com/xyz/spring/raul/SpringbootDemoApplication.java
        modified:   src/main/resources/application.properties

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        newFile.txt

So now we have files in 3 different buckets of Git. 
1)Changes to be commited - thats the Git staging area that contains the pom.xml file.
2)Changes not staged for commit - Two files that are modified in the working directory, so that's changes not staged for commit. files application.properites and SpringbootDemoApplication.java.
3)Untracked files - Files that are not yet tracked by Git. Our new file newFile.txt lies with in this bucket.

So doing all this work perhaps i have realized that this really does belong on a new feature branch not against master. So one of the favourite ways of all developers to correct this is actually to user Git's stash command to move all these changes to a feature branch.

7.Moving all the changes to a feature branch
So doing all this work perhaps i have realized that this really does belong on a new feature branch not against master. So one of the favourite ways of all developers to correct this is actually to user Git's stash command to move all these changes to a feature branch. so lets do that.
First we need to add all the files that have been modified or that are new to a stash.
$ git stash -u
where -u parameter we are saving not only the modified files but also new files.

8.Verify the status
$ git status
No local changes to save

By doing a git status command we now have a clean working directory.

9.Applying stash to a new branch
Now lets go and apply stash to a new branch. And to do that we are going to issue the command 
	$ git stash branch branchName
		where branchName is the name of the branch

$ git stash branch branch-stash-test
Switched to a new branch 'branch-stash-test'
<stdin>:9: trailing whitespace.
<!-- Starter JPA Beg-->
warning: 1 line adds whitespace errors.
On branch branch-stash-test
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        modified:   pom.xml

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   src/main/java/com/xyz/spring/raul/SpringbootDemoApplication.java
        modified:   src/main/resources/application.properties

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        newFile.txt

Dropped refs/stash@{0} (563ae07143d6384033e4ef0ae4899987bc60d23d)

When i pressed Enter, several things happened all at once. First of all the the new branch branch-stash-test is created. Then we switched into that branch, and then our stash is applied. And at the very end that same stash is dropped. We can confirm that by listing all the stashes
	$ git stash list
	It comes as empty. Currently there are no stashes in the stash list. And if we do a git status then we have the same output.
	
	
10.Verify the status
$ git status
On branch branch-stash-test
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        modified:   pom.xml

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   src/main/java/com/xyz/spring/raul/SpringbootDemoApplication.java
        modified:   src/main/resources/application.properties

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        newFile.txt

Now we can see that we got the same output as the git stash branch command gave us; basically the same git status that we had back on stash-master prior to issuing the git stash command.

11.Commiting our changes
Now that we have done all this, lets go and ahead and commit our changes that we have.
$ git add .
Now we have added all the files to the staging area
Now all the files are being modified and are in the changes to be commited state, that is our git staging area. So now all we have to do is commit.
$ git commit -m "Changes after git status branch command we have stashed our new changes to a new branch"

Now we have successfully commited our changes.
So at this point i am done with this branch and i am going to integrate these changes to master-stash branch.

12.Switching to master-stash branch
So at this point i am done with this branch and i am going to integrate these changes to master-stash branch. So i am switching to our master branch
$ git checkout master-stash

13.Merge the new changes
Now we are in master branch, lets merge the new changes from branch-stash-test branch to our master branch.
$ git merge branch-stash-test
Updating baa6a97..9d3ccf4
Fast-forward
 newFile.txt                                                      | 1 +
 pom.xml                                                          | 2 ++
 src/main/java/com/xyz/spring/raul/SpringbootDemoApplication.java | 1 +
 src/main/resources/application.properties                        | 3 ++-
 4 files changed, 6 insertions(+), 1 deletion(-)
 create mode 100644 newFile.txt

Now that we have done that which resulted in a fast forward merge. So lets get rid of the branch-stash-test branch

14.Deleting branch-stash-test branch
git branch -d branch-stash-test

Now that branch-stash-test branch is being deleted. if we list the branch
$ git branch 
this lists out all the local branches but we can't see branch-stash-test branch.

-----------
+ Tagging
-----------

Creating a new Tag
------------------
eg : $ git tag tagName
$ git tag myTag
In this case "myTag" with a capital "T". Doing so will have a tag created, and the type of tag we just created is called a light weight tag.

Listing of tags
---------------
We can also see the list of tags.
eg : $ git tag --list
$ git tag --list
Note that you have to provide the two hyphens or you will be creating a new tag called list.

Deleting of a tag
-----------------
In order to delete a tag we type the below command
eg : $ git tag --delete tagName
here the name of te tag is myTag
$ git tag --delete myTag


1. Simple Tag Example/Lightweight Tags
--------------------------------------
In this session we will understand what is tagging, so we will start off with light weight tags.
If we want to mark a significant events or milestones in the repository. And the way i can accomplish that is by using Git's tagging support. Tags are just nothing more than labels that we can apply at any commit in the history. So i am going to type git tag and then the name of the tag.
eg $ git tag tagName
$ git tag myTag
In this case "myTag" with a capital "T". Doing so will have a tag created, and the type of tag we just created is called a light weight tag. Its simply just a marker on a particular commit. So if we go back to our log command we have a new item at the very top: "tag:" and then the name of the tag "myTag"

We can use the name of the tag in other Git commands as a reference. For eg: we can just use that with the git show command 
eg : git show tagName
$ git tag myTag
Then Git responds with the commit thats at the tag. So i am going to list my tags again, and for this tag i really don't want to do anythng with them: so i'm going to delete the tag 
$ git tag --delete myTag
Now the tag myTag is been deleted.
If we list the tag's again, Git has nothing to respond with since there are no tags to be listed.

Type git log to understand the commit.
$ git log --oneline --decorate --graph --all
so we can see at the very top our tag is not listed here as well

2. Annotated Tags
-----------------
Create an annotated Tag
-----------------------
So lets create an annotated tag; an annotated tag is similar to lightweight tag except that it has a little bit of extra information.In particular it usually has what's equivalient to a commit message, but for tags. So it has the following syntax
$ git tag -a tagName
where -a specifies its going to be an annotated tag.
eg : $ git stag -a v-1.0
a - indicated its an annotated tag
v-1.0 - is the tagName, since tags often used to denote major milestones or version numbers in source code. Now press Enter
Sine the "-a" treats the tag as annotated tag, our default editor is brought up for the message to be used with annotated tag. So we are going to use the tag message as "release 1.0"; you could have a whole list of releases notes in here or any other information that is relevant to this tag.
When you are done just save and close.
List all the tags
-----------------
So now just lists all the tags
$ git tag --list
So you can see our v-1.0 tag. 

View of Logs
-------------------
Now lets see our tag history
$ git log --oneline --decorate --graph --all
We can see out tag history at the top our last commit has the tag associated "v-1.0"

Show the tag
------------
Type the git show and the name of our tag
$ git show v-1.0
Now when we do the git show command on an annotated tag we get a slightly different output. Now if we remember from the lightweight tag, the output started with the commit and the commit id but with an annotated tag, we start with a tag and the tag name, and the person that issued the tag command, and then the date that the tag was actually created, and along with the tag message. Then after that you start with the commit id and rest of it.

3. Comparing Tags (Differences between tags)
--------------------------------------------
1. List out all the tag's
Lets check whether we have created any tags before. To list out all the tags type the command
$ git tag --list
myTag
we have a tag called myTag

2. Create few tags
 - Change in pom.xml add comment to starter JPA
 - commit the file 
$ git commit -am "Starter JPA Added in pom.xml"	

3. View the logs
$ git log --oneline --graph --decorate --all

-/springboot-demo (tag-test)
$ git log --oneline --decorate --all --graph
* 00c7e12 (HEAD -> tag-test) Starter JPA Added in pom.xml
| * e894178 (rebase-test, rebase-master) rebase-test commit 3 - jpa added
| * e2799dd rebase-test commit 2 - note file added

4. Tag Creation
Our latest commit does not have a tag associated with it. So when ever you issue a tag command it will apply the tag to the current commit. so the syntax is $ git tag -a tagName
$ git tag -a myTag-v1.0
Now we have created a tag myTag-v1.0

5. Create another Tag
 - Open application.properties and add the property server.port and save
 - Commit the file using express commit 
   $ git commit -am "server.port added in application.properties"
 - $ git tag -a myTag-v1.1  
Now we have created a tag myTag-v1.1

6. Listing of all the tags
To list all the tag's type the command
$ git tag --list 
/*******************************/
$ git tag --list
list
myTag
myTag-v1.0
myTag-v1.1
/*******************************/
Here you can see we have created 3 tags and we have listed them out. and we can also view the history
$ git log --oneline --decorate --all --graph
* 5f1755a (HEAD -> tag-test, tag: myTag-v1.1) server.port added in application.properties
* 00c7e12 (tag: myTag-v1.0) Starter JPA Added in pom.xml
| * e894178 (rebase-test, rebase-master) rebase-test commit 3 - jpa added
| * e2799dd rebase-test commit 2 - note file added
| * 41c3dc8 rebase-test commit 1 - starter web added
| * d3c356a rebase-master commit 2 - comment message added to java main
| * f857579 rebase-master commit 1 - server.port added in application.properties
Now we can see the tags applied to the last 2 commits. i.e myTag-v1.0 and myTag-v1.1

7. Viewing Differneces between Tags
the most popular command for displaying differneces in Git is "$ git diff"
So "$ git diff" and then our starting reference to our ending reference. 
In this case our references are going to be our tag names.
$ git diff myTag-v1.0 myTag-v1.1
Not we can see the differences between the two tags. We can also do the same thing with a visual diff/merge tool, if we have configured that.
$ git difftool myTag-v1.0 myTag-v1.1
Now we can see the difference's between the two tags in our difftool, upon closing we will return to the git bash window.



4. Tagging a specific commit (Tagging a Previous Commit)
--------------------------------------------------------
Now to understand how to tag a specific commit, we move on to the working directory of the Git Repository. i.e a clean working directory

1. View the history
$ git log --oneline --decorate --graph --all
Now if you see the logs the last two commits are pertaining to our tag.
Let's say we forgot to tag something that we should have tagged, perhaps a major milestone.
So pick that specific commit. 

2. Create a new tag on a specific commit

$ git log --oneline --decorate --graph --all
* 5f1755a (HEAD -> tag-test, tag: myTag-v1.1) server.port added in application.properties
* 00c7e12 (tag: myTag-v1.0) Starter JPA Added in pom.xml
| * e894178 (rebase-test, rebase-master) rebase-test commit 3 - jpa added
| * e2799dd rebase-test commit 2 - note file added
| * 41c3dc8 rebase-test commit 1 - starter web added
| * d3c356a rebase-master commit 2 - comment message added to java main
| * f857579 rebase-master commit 1 - server.port added in application.properties
|/
| * 9d3ccf4 (branch-stash-test) Made a stash and copied to a new branch
|/
* baa6a97 (tag: myTag, tag: list, origin/master, master) modified source
* 3133925 Banner Text Added


For the example purpose i am going to use the commit "'3133925'"
So the syntax is 
$ git tag -a tagName commitId
where -a indicates its an annotation type of tag.
	  tagName indicates the new name for the tag.
	  commitId indicates the content or till this specific commit all the things should be present in the tag.
$ git tag -a v1.2-alpha 3133925
Now since its an annotated type of tag, the text editor opens and we need to provide the proper message and save the file.

3. View the history
Now if we issue the log command again

* 3133925 (tag: v1.2-alpha) Banner Text Added
| * 638b2ec (origin/basic-petclinic-multilevel-module, basic-petclinic-multilevel-module) pet-clinic folder name changed to springboot-demo. springboot-demo is same folder for other cases.
| * 5f12bc9 Added BaseEntity for model objects
| * 6008133 Adding Servcie to Owner, Pet and Vet
| * c1e144c pom.xml modified to include properties
| * 96ed771 basic maven multilevel module project configuration for pet-clinic
| * 4f74513 (origin/petclinic-basic-model, petclinic-basic-model) Basic setup of petclinic model

You can see the the tag v1.2-alpha is associated to the commit id "3133925"

5.Updating Tags (Updating an existing Tag)
------------------------------------------
To understand how to update a tag, we need to be in a clean working directory.

1.View history
if we type 
$ git log --oneline --decorate --graph --all

We can see various tags, associated to different commits.
$ git log --oneline --decorate --graph --all
* 5f1755a (HEAD -> tag-test, tag: myTag-v1.1) server.port added in application.properties
* 00c7e12 (tag: myTag-v1.0) Starter JPA Added in pom.xml
| * e894178 (rebase-test, rebase-master) rebase-test commit 3 - jpa added
| * e2799dd rebase-test commit 2 - note file added
| * 41c3dc8 rebase-test commit 1 - starter web added
| * d3c356a rebase-master commit 2 - comment message added to java main
| * f857579 rebase-master commit 1 - server.port added in application.properties
|/
| * 9d3ccf4 (branch-stash-test) Made a stash and copied to a new branch
|/
* baa6a97 (tag: myTag, tag: list, origin/master, master) modified source
* 3133925 (tag: v1.2-beta, tag: v1.2-alpha) Banner Text Added
| * 638b2ec (origin/basic-petclinic-multilevel-module, basic-petclinic-multilevel-module) pet-clinic folder name changed to springboot-demo. springboot-demo is same folder for other cases.
| * 5f12bc9 Added BaseEntity for model objects
| * 6008133 Adding Servcie to Owner, Pet and Vet
| * c1e144c pom.xml modified to include properties
| * 96ed771 basic maven multilevel module project configuration for pet-clinic
| * 4f74513 (origin/petclinic-basic-model, petclinic-basic-model) Basic setup of petclinic model
|/
| * 55e7594 (origin/basic-spring-bean-lifecycle, basic-spring-bean-lifecycle) Bean Lifecycle and Bean PostProcessing methods added.
|/
| * 5ad628f (origin/basic-spring-default-profile, basic-spring-default-profile) Basic Spring Default Profile Changes
| * a0b5200 (origin/basic-spring-profiles, basic-spring-profiles) basic profile changes
|/
| * 03899f3 (origin/basic-spring-primary, basic-spring-primary) @Primary Annotation Demo Added
|/
| * cbd26e6 (origin/basic-spring-qualifier, basic-spring-qualifier) Qualifier Annotation Fix
| * 5933de2 Initial Commit with bugs
|/
| * c59a8d6 (origin/basic-dependency-with-spring, basic-dependency-with-spring) Dependency Injection using Spring Framework
|/
* 919cce6 Junit 5 added for pom.xml

In the previous example we associated a tag "v1.2-alpha" to this commit id "3133925", now let see i actually wanted to associate with the Adding of JPA to pom.xml "00c7e12". So i am going to copy that and there will be couple of approaches that we can take

 - Approach 1
	The first approach is simply to delete the tag and then recreate the tag to the corresponding correct commit Id 
	
 - Approach 2
	Or we can do it by forcing it. We will see how to implement it. So the syntax for updating a tag forcefully is 
$ git tag -a tagName -f correctCommitId
where -f is force update

$ git tag -a v1.2-alpha -f 00c7e12
Now the text editor opens and we need to put the tag message. Save and close the file.
You can see the below message
Updated tag 'v1.2-alpha' (was 0adb711)

2.View History
$ git log --oneline --decorate --graph --all

$ git log --oneline --decorate --graph --all
* 5f1755a (HEAD -> tag-test, tag: myTag-v1.1) server.port added in application.properties
* 00c7e12 (tag: v1.2-alpha, tag: myTag-v1.0) Starter JPA Added in pom.xml

Now we can see the v1.2-alpha is associated to 00c7e12 commit id.

6.Using Tags with Github (Remote Tagging)
-----------------------------------------
Now i am currently in the Git Repository and i have a clean working directory.
If i list all the tags
$ git tag --list
list
myTag
myTag-v1.0
myTag-v1.1
v1.2-alpha
v1.2-beta
you can see we have several tags created. If we look at the history using git log command
$ git log --oneline --graph --decorate --all
* 5f1755a (HEAD -> tag-test, tag: myTag-v1.1) server.port added in application.properties
* 00c7e12 (tag: v1.2-alpha, tag: myTag-v1.0) Starter JPA Added in pom.xml
| * e894178 (rebase-test, rebase-master) rebase-test commit 3 - jpa added
| * e2799dd rebase-test commit 2 - note file added
| * 41c3dc8 rebase-test commit 1 - starter web added
| * d3c356a rebase-master commit 2 - comment message added to java main
| * f857579 rebase-master commit 1 - server.port added in application.properties
|/
| * 9d3ccf4 (branch-stash-test) Made a stash and copied to a new branch
|/
* baa6a97 (tag: myTag, tag: list, origin/master, master) modified source
* 3133925 (tag: v1.2-beta) Banner Text Added
| * 638b2ec (origin/basic-petclinic-multilevel-module, basic-petclinic-multilevel-module) pet-clinic folder name changed to springboot-demo. springboot-demo is same folder for other cases.
| * 5f12bc9 Added BaseEntity for model objects
| * 6008133 Adding Servcie to Owner, Pet and Vet
| * c1e144c pom.xml modified to include properties
| * 96ed771 basic maven multilevel module project configuration for pet-clinic
| * 4f74513 (origin/petclinic-basic-model, petclinic-basic-model) Basic setup of petclinic model
|/
| * 55e7594 (origin/basic-spring-bean-lifecycle, basic-spring-bean-lifecycle) Bean Lifecycle and Bean PostProcessing methods added.
|/
| * 5ad628f (origin/basic-spring-default-profile, basic-spring-default-profile) Basic Spring Default Profile Changes
| * a0b5200 (origin/basic-spring-profiles, basic-spring-profiles) basic profile changes
|/
| * 03899f3 (origin/basic-spring-primary, basic-spring-primary) @Primary Annotation Demo Added
|/
| * cbd26e6 (origin/basic-spring-qualifier, basic-spring-qualifier) Qualifier Annotation Fix
| * 5933de2 Initial Commit with bugs
|/
| * c59a8d6 (origin/basic-dependency-with-spring, basic-dependency-with-spring) Dependency Injection using Spring Framework
|/
* 919cce6 Junit 5 added for pom.xml
| * 9b95b37 (origin/basic-no-spring-dependency, basic-no-spring-dependency) Modified setter method
| *   7cb52e8 Merge Resolved
| |\
| | * 91f45db Setter Injection Added
| * | 235cb3b File name changed from SetterController to SetterInjectionController
| |/
| * 78f65d7 creating object with out spring depencdency
| | * 0596cd3 (origin/basic-spring-context, basic-spring-context) pom modified to add junit 5
| |/
| * 017338b Context obtained
|/
| * d094265 (origin/jpa-basic-setup, jpa-basic-setup) starter web added in pom.xml
| * d4c0e3e Jpa basic many to many relationship
|/
* 222215d Initial Springboot Setup
* 42e9b3c Initial Springboot Setup
Now you can see where each of the tag's associate with a particular commit, with our most recent commit being associated with the tag :myTag-v1.1

1. Viewing Repository from browser
Open your favourite browser and navigae to our workspace in Git

a. Go to releases tab and this is how GitHub tracks tags, and currently there aren't any. So i am going back to my terminal.


2. Push one particular tag to remote
So the first thing what i want to do is actually push one particular tag, So in order to push one tag to the remote repository the syntax is $ git push origin tagName
i.e the name of the tag i wish to push
$ git push origin v1.2-beta
And press Enter, so what Git will do is look to see if there are any differences, synchronize the commits if necessary, and then push the tag.

3. Viewing Repository from browser
And now if we go and navigae to our workspace in Git

a. Go to releases tab and this is how GitHub tracks tags, we have our tag v1.2-beta.
You can also see the commit id associated with the tag, now looking at my commit history if i go to my commits, you see the commit that starts with 42f4 is the last commit on Github which is the commit that is associated with v1.2-beta.

4. Push one more tag to remote
$ git push origin myTag-v1.0
Now not only we did push the tag names myTag-v1.0, but the commits that were associated with the tag are also on Github. 

5. Viewing Repository from browser
And now if we go and navigae to our workspace in Git, and refresh our commits i.e go back to releases, we can see that we have our myTag-v1.0 pushed to github. If we click on that commit, you can see that we have the changes for that commit on GitHub, and now there are still several tags that are not on Github.

6. Pushing all the tags to github (using a single push multiple tags will be moved to remote)
now there are still several tags that are not on Github, i.e to push all the local tag's up to Github all at one time we can issue a git push with the syntax
$ git push origin branchName --tags
where --tags will synchronize our master branch as well as push up any tags that are missing.
So in our case we are in the tag-test branch
$ git push origin tag-test --tags

7. Viewing Repository from browser
So now if we return to Github,refresh and now we have an updated last commit. If we go to releases we can see we have all our release tags. In Github releases are tracked by Tags. And for each of the tags your can go to the "..." and it will show you the tag message. It also lists with commit that each of these tags are associated with. In addition to that Github automatically generates a .zip file or a tarball file that contains all the source so that commit. 


8.Deleting a tag from remote
What if you accidentally pushed a tag that shouldn't be on Github. How would you delete a tag that's on Github?
Go to our terminal, and use the below syntax
$ git push origin :tagName
What this is literally saying is push nothing to this tagname 
Now press enter and the Git responds back with the message by letting us know that the tagName has been deleted. 
$ git push origin :v1.2-beta

9. Viewing Repository from browser
So now if we return to Github,refresh and now we have an updated last commit. If we go to releases we can see we have successfully removed the v1.2-beta tag from the remote repository.
Now we still have this tag "v1.2-beta" in our local repository but its just not on the remote repository.

------------------------------
+ Bonus : Office Hour Sessions
------------------------------

1. Reset and Reflog (Time travel with Git)
------------------------------------------
Lets understand how we can traverse the head but actually traverse our branch using head.
In order to understand the concepts, we need a branch with plenty of commits.

-/springboot-demo (reset-master)
$ git log --oneline --graph --all --decorate
* 5ef4d02 (HEAD -> reset-master) comments added in CommonUtils
* 7123754 Displaying only name of the student from sales dept
* 729b6dd Displaying only student of Sales dept
* 43dcf58 Added Department and Displaying Student Info
* 307389b Contact Added for CommonUtils
* 00b4707 Added CommonUtils Initial Draft

As you can see i have several commits and they are represented by Asterisk and the way it works is we have the first commit at the bottom and the last commit at the top. And HEAD always points to the last commit on the current branch, and if you want to go back one commit we could use the syntax with the caret(^) or we can use atherate(@) symbol curly brace notation.

A) Reset One level Back (Go back to previous commit)
--------------------------------------------------
eg : $ git reset HEAD^1
This will go one level back.

eg : $ git reset HEAD^2
This will go two level back.

eg : $ git reset HEAD^5
This will go five level back.

From the above log history if i want to go one level back then i need to type
$ git reset HEAD^1

git responds back saying
Unstaged changes after reset:
M       src/main/java/com/xyz/spring/raul/util/CommonUtils.java

View Status
-----------
-/springboot-demo (reset-master)
$ git status
On branch reset-master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   src/main/java/com/xyz/spring/raul/util/CommonUtils.java

no changes added to commit (use "git add" and/or "git commit -a")

View History
------------
-/springboot-demo (reset-master)
$ git log --oneline --graph --all --decorate
* 7123754 (HEAD -> reset-master) Displaying only name of the student from sales dept
* 729b6dd Displaying only student of Sales dept
* 43dcf58 Added Department and Displaying Student Info
* 307389b Contact Added for CommonUtils
* 00b4707 Added CommonUtils Initial Draft

Now we have reset our HEAD to one level back i.e previous commit. We can discard the working directory items and commit then do a push if we have accidentally did a commit.

Now if we want to go up one level then we have to use the reflog command.

B) Reflog
---------
Git Reflog shows us everything we have done.
Git Log really shows us history but Git Reflog actually shows us all. i.e its a log of everything we have done.

-/springboot-demo (reset-master)
$ git reflog
43dcf58 (HEAD -> reset-master) HEAD@{0}: reset: moving to HEAD^1
729b6dd HEAD@{1}: reset: moving to HEAD^
7123754 HEAD@{2}: reset: moving to HEAD^1
5ef4d02 HEAD@{3}: commit: comments added in CommonUtils
7123754 HEAD@{4}: commit: Displaying only name of the student from sales dept
729b6dd HEAD@{5}: commit: Displaying only student of Sales dept
43dcf58 (HEAD -> reset-master) HEAD@{6}: commit: Added Department and Displaying Student Info
307389b HEAD@{7}: commit: Contact Added for CommonUtils
00b4707 HEAD@{8}: commit: Added CommonUtils Initial Draft

So infact the first 3 are the three items that we did so we went back we did our reset few times and then it continues.
Now we can see the syntax of the HEAD at the current commit basically 0 and then we go backwards and HEAD{3}, here is our you know basically getting back to where we were.

So we can do that couple of ways.

Approach-1 - Using Commit Id
1. Select the commit id 
From the reflog select the commit id and provide it as an argument for the git reset command.
$ git reset commitId
$ git reset 5ef4d02

View the History
----------------
-/springboot-demo (reset-master)
$ git log --oneline --graph --decorate --all
* 5ef4d02 (HEAD -> reset-master) comments added in CommonUtils
* 7123754 Displaying only name of the student from sales dept
* 729b6dd Displaying only student of Sales dept
* 43dcf58 Added Department and Displaying Student Info
* 307389b Contact Added for CommonUtils
* 00b4707 Added CommonUtils Initial Draft

Now if you scroll up you can see our HEAD is pointing to the same commit Id. So i just went back forward although i do that i had to go backwards in the reflog. That's a little confusing but you can actually go backwards and forwards through your commit log. Becasue you dont actually lose any history even though it looks like that when you do the git log command most of the time but if you ever get lost you are wondering hey did i miss something.

Approach-2 - Using Reflog syntax(@{})
Now using approach-2 how can we move up a commit. To understand better we need to go few commits back then using approach-2 we will come to the point where we have started.

Moving 3 commits Back.
----------------------
- View History
	-/springboot-demo (reset-master)
		$ git log --oneline --graph --decorate --all
		* 5ef4d02 (HEAD -> reset-master) comments added in CommonUtils
		* 7123754 Displaying only name of the student from sales dept
		* 729b6dd Displaying only student of Sales dept
		* 43dcf58 Added Department and Displaying Student Info
		* 307389b Contact Added for CommonUtils
		* 00b4707 Added CommonUtils Initial Draft
		| * 5f1755a (tag: myTag-v1.1) server.port added in application.properties
		| * 00c7e12 (tag: v1.2-alpha, tag: myTag-v1.0) Starter JPA Added in pom.xml
		|/
		| * 9d3ccf4 (branch-stash-test) Made a stash and copied to a new branch
		|/
Now the current commit is 5ef4d02, i want to go back 3 levels from the current commit. So for that if i was using 'caret notation' i would have written $ git reset HEAD^3 the same thing i can write using Reflog syntax
$ git reset HEAD@{n}
where n indicates the a numeric value where we need to move or point our HEAD.
$ git reset HEAD@{3}

-/springboot-demo (reset-master)
$ git reset HEAD@{3}
Unstaged changes after reset:
M       src/main/java/com/xyz/spring/raul/util/CommonUtils.java

- View History	
-/springboot-demo (reset-master)
$ git log --oneline --graph --decorate --all
* 7123754 (HEAD -> reset-master) Displaying only name of the student from sales dept
* 729b6dd Displaying only student of Sales dept
* 43dcf58 Added Department and Displaying Student Info
* 307389b Contact Added for CommonUtils
* 00b4707 Added CommonUtils Initial Draft
| * 5f1755a (tag: myTag-v1.1) server.port added in application.properties
| * 00c7e12 (tag: v1.2-alpha, tag: myTag-v1.0) Starter JPA Added in pom.xml
|/
| * 9d3ccf4 (branch-stash-test) Made a stash and copied to a new branch

Differences between different types of reset's
----------------------------------------------
There are basically 3 types of reset's/w
1.Soft Reset
2.Mixed Reset
3.Hard Reset

Mixed Reset
-----------
By default you get mixed which is a kind of wierd but if you are familar with the three major parts of GIT i.e060e24
a.Where you have your local changes on your working directory
b.Then you have the staging area
c.Then you have the commit

So if you basically do a mixed history will basically reset what you are working i.e staging area and then it will reset the head to whatever you tell it to go.

Hard Reset
----------
The other option is called Hard Reset, which is the extreme end of things as the most destructive at that will both reset your local working directory as well as the staging area and then move the head to where ever your tell it to go.

Soft Reset
----------
The soft reset is the least destructive of them all. It just points the header or pointer to a new location and that doesn't affect your staging area nor does it affect your working directory.


2. Compare Branches Via GitHub (Office Hr's, Session-1)
-------------------------------------------------------

3. Compare Branches Via Command Line (Office Hr's, Session-1)
-------------------------------------------------------------

4. Getting Help
---------------
Git normally has more esoteric commands, there is no shame in looking at the help manual. The syntax is git help commandName/operationName
eg : $ git help stash

This will tell you everything that you need to know about stash.Probably more than you care to know and can get pretty geeky most of the documentation it provides more info.
This will open the browser and provides more help.

5. Cherry Pick - Apply a specific commit elsewhere
--------------------------------------------------
- Use case of Cherrypick
Lets say if we have 2 branches, say master and developement branch. And you decide that there is a hotfix that you had to apply on master and you give that there was a production issue and you need to put that fix back to your development stream where you need to pick one particular commit and maybe put it into master as your commit as your hotfix because you had to fix it at a particular time in history. Then you can use cherry pick to just bring that one single commit down to wherever you need to go. And that's why you would want to cherry pick. Its little bit more of an advanced topic but its definitely something you can do and you could result in a merge conflict when you do cherry pick.

For example purpose i have created two branches master-cherry and develop-cherry

1. Check the status
Switch on to develop-cherry branch and make changes in 2 or more files and check the status

-/springboot-demo (develop-cherry)
$ git status
On branch develop-cherry
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   pom.xml
        modified:   src/main/resources/application.properties

no changes added to commit (use "git add" and/or "git commit -a")

2. Do an express commit
We are going to do an express commit by 
$ git commit -am "Express Commit of pom.xml and application.properties for understanding cherry pick"

-/springboot-demo (develop-cherry)
$ git commit -am "Express Commit of pom.xml and application.properties for understanding cherry pick"
[develop-cherry 2aa84d1] Express Commit of pom.xml and application.properties for understanding cherry pick
 2 files changed, 6 insertions(+), 1 deletion(-)
 
3. Change or Modify one more file and commit

 - File Modified
	-/springboot-demo (develop-cherry)
	$ git status
	On branch develop-cherry
	Changes not staged for commit:
	  (use "git add <file>..." to update what will be committed)
	  (use "git checkout -- <file>..." to discard changes in working directory)

			modified:   src/main/java/com/xyz/spring/raul/SpringbootDemoApplication.java

	no changes added to commit (use "git add" and/or "git commit -a")

 - Express Commit
	-/springboot-demo (develop-cherry)
	$ git commit -am "Modifying Java file to understand cherry pick but this should not be merged to master"
	[develop-cherry a02d729] Modifying Java file to understand cherry pick but this should not be merged to master
	 1 file changed, 1 insertion(+), 1 deletion(-)
 
4. View History
Now view the history
-/springboot-demo (develop-cherry)
$ git log --oneline --graph --decorate --all
* a02d729 (HEAD -> develop-cherry) Modifying Java file to understand cherry pick but this should not be merged to master
* 2aa84d1 Express Commit of pom.xml and application.properties for understanding cherry pick
* 5ef4d02 (master-cherry) comments added in CommonUtils
* 7123754 Displaying only name of the student from sales dept
* 729b6dd Displaying only student of Sales dept
* 43dcf58 Added Department and Displaying Student Info
* 307389b Contact Added for CommonUtils
* 00b4707 Added CommonUtils Initial Draft

So now i actually want to save the commit '2aa84d1' so i copy the commit ID and switch to my master-cherry branch
$ git checkout master-cherry
 
5. Perform cherry-pick

For doing a cherry pick the syntax is 
$ git cherry-pick commitId

So in our example the commit id is '2aa84d1' and its in cherry-develop branch and i need to pick that commit from cherry-develop to cherry-master branch. So i need to run the below command from my master branch
$ git cherry-pick 2aa84d1

-/springboot-demo (master-cherry)
$ git cherry-pick 2aa84d1
[master-cherry b8ab42f] Express Commit of pom.xml and application.properties for understanding cherry pick
 Date: Sat Jul 18 11:05:59 2020 +0530
 2 files changed, 6 insertions(+), 1 deletion(-)

6. View the History.
-/springboot-demo (master-cherry)
$ git log --oneline --graph --decorate --all
* b8ab42f (HEAD -> master-cherry) Express Commit of pom.xml and application.properties for understanding cherry pick
| * a02d729 (develop-cherry) Modifying Java file to understand cherry pick but this should not be merged to master
| * 2aa84d1 Express Commit of pom.xml and application.properties for understanding cherry pick
|/
* 5ef4d02 comments added in CommonUtils
* 7123754 Displaying only name of the student from sales dept
* 729b6dd Displaying only student of Sales dept
* 43dcf58 Added Department and Displaying Student Info
* 307389b Contact Added for CommonUtils
* 00b4707 Added CommonUtils Initial Draft

-------------------------------------------------------------- Course Complete ---------------------------------------------------------------
Double Dot Operator
-------------------
It is the default operator in git diff
git diff master..feature or git diff master feature command will display all the differences from G to C (that is, including F and G)

Triple Dot Operator
-------------------
It shows the difference between master and feature branch starting at the last common commit E.
git diff master...feature command's output would be the difference in feature branch (that is, only A, B, and C)


Git Log
-------
Git log command shows the list of commits in the current branch. You can use it in the following ways:

git log -2 displays the history of last two commits
git log commit_id shows the history starting from commit_id
git log filename displays the list of commits for the file

-Flags
You can enhance the output of git log command using these optional flags:

--oneline: Fits the log output to a single line
--decorate: Adds a symbolic pointer to the output
--graph: Gives a graphical representation to the log output
--grep=<pattern>: Filters the log output and displays the output which matches the specified pattern
For example, git log --oneline

Git Show
--------
git show is a versatile command which is similar to git log, but with few additional features.

You can pass different arguments like:
commit_id
tree

It shows the author's name, timestamp, commit message, and difference from the previous commit.
For commit range git show --oneline HEAD~2..HEAD, it gets resolved, and each commit is displayed individually.


Git Diff
--------
git diff function takes two input datasets and outputs the changes between them.

Datasets can be commits, branch, files and more.

git diff HEAD~1 HEAD shows the difference between two commits.

Cheat Sheet
-----------
- git log -p: Prints full details of each commit
- git log --grep-reflog=<pattern>: Shows the list of commits when commit message matches regular expression pattern
- git log -follow ./path/to/filename: Shows the history for the current file
- git show: Outputs content changes of the specified commit
- git diff --color-words: Output has only the color-coded words that have changed
- git diff -staged: Shows the file differences between staging and the last committed version
- git diff .path/to/file: Shows changes in a file compared to the previous commit

Collaborate Using Git
---------------------

Local to Remote
---------------
In the previous topic, whatever you have learned was mostly limited to your local machine. To collaborate with other developers, you need to push your work to the remote repository, and vice-versa, you need to pull others' work from remote to contribute your work to the project.

In Git, remote is a repository on a server where all your team members can place the code to collaborate

Remote URL Types
----------------
You can keep your project code in remote servers like GitHub, GitLab or on a self-hosted server. Git sets a default name for your remote URL as origin

Remote URL can be one of the two types:
1. HTTPS URL like https://github.com/user/repo.git: You can clone/push using your user name and password
2. SSH URL, like git@github.com:user/repo.git: You need to configure SSH keys in Github/Gitlab account and local machine
Keep reading to find out the Git commands used to collaborate with other developers

Git Clone
---------
To get source code of an already existing project from remote repo (For example, Github), you can use git clone <url> command.
For example, git clone https://github.com/facebook/react.git
This command downloads the complete project, all branches, commits and logs from the given remote URL (react repo here) to your local machine.

Git Pull
--------
Your teammate has pushed the changes to the project's remote repo where you are also working. You can now pull the changes to your local machine using any one of the following commands.

git pull is the convenient shortcut key to fetch and merge the content.
	- git pull <remote_name> <branch_name>

git fetch command downloads the remote content to your local repo, without changing your code changes.
	- git fetch <remote_name> <branch_name> fetches the content from that specific branch in remote to your current working area
	
git merge command merges the fetched remote content to the local working tree
	- git merge <remote_name>/<branch_name> merges the content to the specified branch.	

Git Push
--------
To keep your changes and work in remote repo, you need to push the branch using the command git push <remote_name> <branch_name>
Git push takes two arguments, namely:
	- <remote_name>
	- <branch_name>	
For example, git push origin master, where:
	- origin will contain the remote URL
	- master is the branch that is pushed

Git Remote
----------
The syntax to link your local repo with remote repo is:	
	- git remote add <remote_name> <remote_url>

It takes two arguments, namely:
	<remote_name>, let us take default name origin
	<remote_url>, let us take https_url https://github.com/play/repo.git

For example: git remote add origin https://github.com/play/repo.git	

Cheat Sheet
	- git clone: Get the complete project from remote to your local machine
	- get pull origin <branch_name>: Get the new changes from remote branch to local branch
	- git push origin <branch_name>: Send your local branch changes to the remote branch
	- git remote add <name> <url>: Add a new remote repo link to your local repo
	- git remote -v: List all the remote repo URLs linked to your local repo
	
Building new Features using Using Branches
------------------------------------------
To build new features without affecting the current working code, you need to:
 - Create new branch from the master git branch <branchname>. Here you will write code for the new feature.
 - Merge the feature branch with the master (or other branch where you want it to be). You can merge two branches locally or in remote.
 
What is Branch in Git?
----------------------
A Branch is a copy of your complete project, where you can add new changes and develop new features. Technically, it is a collection of commits.

When you create a new Git project, it has a branch called master by default. Even in the projects you clone from Github/Gitlab, a master branch is always present. Master branch usually has the stable and working version of your application, and hence it can be modified only by a few access-controlled users.

Branch Operations
-----------------
You can do the following with branch:
	- Creating new branch: git checkout -b <branch-name>
	- Pushing branch from local to remote repo: git push origin <branch-name>
	- Renaming branch:
		- Renaming local branch: git branch -m old-name new-name
		- Renaming remote branch: git push origin :old-name new-name
	- Deleting branch:
		- Deleting local branch: git branch -d <branch-name>
		- Deleting remote branch: git push origin -d <branch-name> 

New Branches For New Features
-----------------------------		
In a project, two developers need to build sign-in and sign-up pages at the same time. How can they do that without affecting the existing application?
They can create new branches for each new feature, such as signin and signup branches and work on the features parallelly.

Building New Feature: Signin
----------------------------
For a new feature to be built:
	- Create a new branch from the master branch: 
		git checkout -b signin
	- Add your new code in the new feature branch: 
		git add -A
	- Commit your changes once done: 
		git commit -m "add signin page"
	- Push your changes to the remote: 
		git push origin signin
	- As your sign-in feature is ready in a different branch, now you can merge it with the master branch.

To see the difference between two branches (master branch and test branch), you can execute the following command
	git diff master test

Cheat Sheet
	- git branch -a: Lists all the branches
	- git branch -d <branch-name>: Deletes the branch in local repo
	- git checkout -b: Creates a branch and switches to it
	- git checkout <branch-name>: Switches to the provided branch	
	
Integrating Changes
-------------------
Once your have developed your feature in a separate branch, you need to integrate the feature and master branch. You can do that using one of the following two commands:
	- merge
	- rebase
	
What is Git Merge?
------------------
Merge is an operation to integrate changes from one branch to another branch by adding a new commit
	
Merging Feature Branch: Signin to Master
You can merge the signin branch with the master in two ways:
	- In your local and push master: 
		git merge master signin && 
		git push origin master
	- In remote server: You need to create a new Pull request(or Merge request) from signin branch to master branch in Github portal

What is Git Rebase?
-------------------
Rebase is an operation to integrate changes from one branch to another. It is an alternative to the Merge command.

If you are re-basing feature branch with master, the command will remove the original commits on feature, bring all the commits from master to feature and add the original commits on top of it.
This changes the commit hashes and re-writes the history (as shown in gif in a different color).
This gives linear flow of development when you look at the history of repo.	

Merge vs. Rebase
----------------
While merge and rebase are both used to integrate changes of two branches, let us see how they differ and which one you can use.

Merge
1. Creates new commit while integrating changes from one branch to another
2. It is safe in nature, as it does not re-write the history of your feature branch
3. When your feature branch is in remote and someone else is creating new branch on top of your feature branch. Use git merge to get the changes from master to feature.

Rebase
1.Does not create any new commit while integrating changes from one branch to another
2.It is destructive in nature, meaning, if you rebase your feature branch with latest changes in master branch, your feature branch commit hashes are changes, re-writing history.
3.When your feature branch is local and changing history will not affect others. Use git rebase to get new changes from master to your feature branch.

Cheat Sheet
	- git merge <branch>: Merges <branch> to current branch
	- git rebase <base>: Rebases the current branch onto the base (branch name, commit ID, tag)
	- git rebase -i <base>: Performs interactive rebase. Launches editor where you can specify command on each commit to transform it.
	- git rebase --abort: Cancels rebasing and goes back to the previous commit
	- git rebase --continue: Continues rebasing after resolving the rebase conflicts
	- git pull --rebase: Fetches the remote copy and rebases it into the current branch of the local copy
	

The Conflict
------------
Suppose you have planned to go for a movie with your family at 8 PM tomorrow. And at the same time, your best friend has asked you to join for dinner.

What will you do? Confused?

Well, this is what happens to Git, conflict arises when two developers change the same line of code. Git fails to understand which line to keep and which one to delete. So it asks you to resolve the conflict.

Managing Changes (Undo Changes)
-------------------------------
When you make a mistake in Word, what do you do? Ctrl+Z, right?

You cannot undo your mistakes in Git as you do in Word. But don't worry, Git gives you the following.
Set of commands to undo your changes:
	- amend
	- checkout
	- reset
	- revert

Set of commands to undo/remove your files:
	- rm
	- clean

- Amend
-------
git commit --amend command is used to fix your previous commit where you do not want to add a new commit.

You can:
Correct your typos in commit messages, Add small changes in the file that you missed adding in the last commit
This command re-writes history by changing the commit-hash and the old commit will no longer be on the branch. Be cautious and avoid amending on public commits (commits you have already pushed to remote branch). Amending a public commit might create merge conflicts for other developers.

- Git Checkout
--------------
Checkout is used to switch. You can switch between branches, commits, and files. Here you will learn how to use this command to undo changes.
You can apply checkout command on
 - Working file
 - Commit

- Checkout Files
----------------
If this is what you feel, you can use checkout command to discard all your changes from your working area and switch to the last committed version of your file. This command will help you restart your work as if nothing happened.

When working with Git, a common scenario is to undo changes in the working directory. The command git checkout will replace everything in the working directory to the last committed version.

To replace all files, use a dot (.) to indicate the current directory. If not, list the directories/files separated by spaces.

Example: git checkout filename

- Checkout Commits
------------------
While debugging the application, if this thought crossed your mind, then you can use git checkout command to switch to a specific commit.

For example: git checkout commitSHA
 - commitSHA is the commit hash to identify it uniquely. You can find this using git log
 - This command creates a detached head, meaning, this will give you a temporary branch to work and debug.
 - Avoid creating any new commits here, as this is a temporary branch
 
- Git Reset
-----------
Reset, as the name says, is used to re-set your work to a specific point in time (a commit). It is a powerful and versatile command, using which you can even undo the changes that you have already committed.

Imagine your Git history as a timeline, then you can quickly jump to a specific time in the past and reset your work as if nothing happened.

If you are in the middle of a commit after adding files to the staging area, and then change your mind, use the git reset command. git reset will move files from the staging area back to the working directory. If you want to reset all files, use a . to indicate the current directory. If not, list the files, separated by spaces.

This is very useful to keep the commits small and focused, because you can move files out of the staging area if you have added too many.

Next, you will learn how to apply reset command on:
 - staged files
 - commits 
	- Reset Files
	If you have staged your changes and forgot to add something, you can reset the file, so the file is moved from staging to working area where you can make the required changes.

	For example: git reset filename

Reset on Commits: Types
-----------------------
You tracked a bug in your project which is due to a rogue commit (commit 3 in the gif).

You can move to the previous commit where the app is working fine (commit 2 in the gif). Did you wonder what will happen to the changes in those two commits that you are skipping? You can use one of the following three flags, which decides in which stage the changes should move:

--soft: This moves your commit changes into staging area and does not affect your current working area.

--hard: This deletes all the commit changes. Be cautious with this flag. You might lose your changes as this flag resets both staging area and working directory to match the <commit>.

--mixed: This is the default operating mode, where your commit changes are moved to working area.
 
-Reseting Branch Commits: Example

Example: git reset commitSHA

 - This executes git reset --mixed commitSHA by default, moving all the changes to the working directory
	You can find SHA code of your commit (where you want to move) using git log
	reset command adds a new commit, re-writing your history
	Avoid reset command, if the branch you want to reset is public (in remote), and somebody else is building a new feature on top of yours. Instead, you can use revert.

Reset HARD
----------
A git reset --hard combines both git reset and git checkout in a single command. The result will be that the files removed from the staging area and the working directory are returned to the state of the last commit.

-Git Revert
-----------
You tracked a bug in your project which was due to a rogue commit.
git revert is another command to undo changes from an old commit, similar to reset. However, git revert inverses the changes from that old commit and creates a new revert commit, instead of deleting the old commit.

This helps prevent Git from losing history.

If you have already committed files, but realize that you made a mistake, use the command git revert to undo the commits. The command will create a new commit which has the inverse effect of the commit being reverted.

If you have not pushed the changes, git reset HEAD~1 has the same effect, and will remove the last commit.

Revert vs. Reset Commits
------------------------
While both reset and revert can undo your commit changes, the following are a few differences

Revert
------
 -Does not delete commits and preserves history
 -If other developers are using your branch to build new features, prefer revert to undo changes on that branch as it might prevent any conflicts

You can also add a --no-edit flag to use the selected commit message without launching an editor.

The motivation behind creating new commits is because rewriting history in Git is an anti-pattern. If you have pushed your commits, you must create new commits to undo the changes as others may have made commits in the meantime.

Reset
-----
 -Deletes commit and changes history
 -Prefer reset if the branch is only in local	

A git reset --hard combines both git reset and git checkout in a single command. The result will be that the files removed from the staging area and the working directory are returned to the state of the last commit.



Delete Files
------------
Just like changes (in a file), you might also want to undo/remove files. Depending on its status, whether Git is tracking the file or not, you can use the following commands to remove them:
 - git rm
 - git clean
 
Git Rm
------
git rm is used to delete any tracked file from your repository. Files from both the staging area and the working directory can be removed using the same.

These changes will not persist until a new commit is added, which in turn creates a new commit history.

You can get back your deleted files using git reset and git checkout. 

Restore Deleted Files
---------------------
How to restore a deleted file ?
First, find the commit ID where the file was deleted: git rev-list -n 1 HEAD -- filename
Then checkout to that commit ID to get back the file git checkout deletingcommitid^ -- filename

Git Clean
---------
git clean command undoes files from your repo. However, it stands unique from other undo operations like checkout, reset and revert, as it primarily focuses on untracked files.

 - git clean is undoable
 - Git clean makes hard file deletion possible, similar to the Unix rm command.
 - It is good to execute git clean -n command to perform a dry run, which helps to know the list of files to be removed.
 
Cheat Sheet
	- git revert <commit>: Creates a new commit that undoes all changes made in the commit and applies it to the current branch
	- git reset <file>: Moves file changes from staging area to working directory.
	- git reset <commit>: Moves current branch's HEAD tip to the old <commit>. All the changes in the commits (that you skipped to move to the old commit) are moved to the working area.
	- git commit --amend: Adds staged changes to the last commit and allows for editing the old commit message
	- git rm --cached(file_name): Untracks the current file
	- git checkout <commit>: Switches the HEAD to the provided commit 

----------------------------------------------------------------- Fresco End -----------------------------------------------------------------
----------------
 + Using Aliases
----------------

Aliases are used to simplify the commands. Like we name a person with alias names, in git we have a provision to provide alias for our command. Then later on call this alias to invoke the command. So the advantage here is big commands can be made small with aliase's.

Lets look at some example.
1.Git Log
For viewing logs we type the command
git log --all --graph --decorate --oneline

Now this command is very long, so it will be better if we could provide an alias so that invoking it using the alias later instead of typing the long command.
Following are the steps to create an alias.
a) Define the alias command in global scope
$ git config --global alias.onelinegraph 'log --oneline --graph --decorate --all'
Now the alias gets created in the global scope
b) Verify that the alias is created
$ git config --global --list
Now we can see the new alias 'onelinegraph' which is created for the command 'log --oneline --graph --decorate --all'
c) Execute the command
$ git oneliegraph
Now we can see the same logs that we use for the command $ git log --oneline --graph --decorate --all
So going forward we need not user the long command $ git log --oneline --graph --decorate --all instead we can use '$ git oneliegraph'

 
-------------------------
 + Performaing Soft Reset
-------------------------
We are going to use reset command anytime when we want to go back to a previous state, whether that be a previous commit or part of a previous commit or actually just a different commit on.
So there are different cases for each of those and we will talk about when it might be useful to use each and how to get there.
Firstly lets go ahead and start diving in and well we will see how reset works in our local current working directory.

We are creating a new branch to learn reset operation, the branch is learn-reset
$ git checkout -b learn-reset

1. Scenario One
---------------
a) We added a file called reset.txt and modified a file from the learn-reset branch. and when we type status

On branch learn-reset
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   help.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        reset.txt

no changes added to commit (use "git add" and/or "git commit -a")

b) Add the two files
$ git add .
$ git status
On branch learn-reset
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        modified:   help.txt
        new file:   reset.txt
Now we can see that our files are in the staging area and they are ready to commit.

c) Revert the files from staging area and bring back to initial stage.
But now we decided i don't what these changes; so we are going to do $ git reset head and unstage the files.
$ git reset head

$ git reset head
Unstaged changes after reset:
M       help.txt

d) Check the status
Check the status of the repo
$ git status

$ git status
On branch learn-reset
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   help.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        reset.txt

no changes added to commit (use "git add" and/or "git commit -a")

So now we can see the the files are reverted from the staging area to working directory. So we reseted but didn't clean up. Because we basically said we don't want the changes.

So all we accomplished by doing that reset was un-staging files and if we go to help.txt and reset.txt we can still see our changes. i.e we just took them out of the staging area.

So we also have another option available called Partial Reset
If we want to do just a partial reset and remove them from index.

- Taking the above eg: now if i type git status i have 
$ git status
On branch learn-reset
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   help.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        reset.txt

no changes added to commit (use "git add" and/or "git commit -a")

- Adding them to staging area
$ git add .

- Check the status
Now if i check the status
$ git status
On branch learn-reset
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        modified:   help.txt
        new file:   reset.txt

- Partial Reset
now i don't want to add reset.txt anymore but i want to keep help.txt

So i can provide partial reset by specifying the below command
$ git reset fileName
where fileName is the name of the file to be reseted.

$ git reset reset.txt

- Check the status
Now if i check the status
$ git status
On branch learn-reset
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        modified:   help.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        reset.txt
So now we can see i have the modified file help.txt staged and ready to be commited and have the untracked file reset.txt which is not staged. If i were to do a commit at this point i would just get help.txt which is what we want.


So what we have learned is that by doing reset to head we can go back to unstaged but all our changes will take place. And we do reset on a specific file we can remove one of the files from being staged in order to be commited.


d)Commit the help.txt file
$ git commit -m "Changes for help.txt for reset activity"


2. Scenario Two
---------------
Now that we have commited our help.txt. Now i want to revert back or i really don't want the commit i actually want to work on the help.txt file. It wasn't completely finished. So i don't need a commit.

a) View Log History
-------------------
$ git log --oneline --decorate --graph
* 59b07b5 (HEAD -> learn-reset) Changes for help.txt for reset activity
* b481765 (java-mk) mkyong tutorials added.
* 95cceb9 (origin/master, origin/HEAD, master) New Code Added to Master

Now we don't want 59b07b5 commit, we need to go back to b481765.
So this 59b07b5 i don't need it, I want to go back to b481765 where i started.
What i need to do is basically provide the reset command with the commit id i want to point to.
$ git reset commitId
where commitId is the id where our git should point to.

b) Reverting back the commit
----------------------------
So this 59b07b5 i don't need it, I want to go back to b481765 where i started.
What i need to do is basically provide the reset command with the commit id i want to point to.
$ git reset commitId
where commitId is the id where our git should point to.

$ git reset b481765

$ git reset b481765
Unstaged changes after reset:
M       help.txt

So that basically unstaged our changes after reset if i look at the status i can see that i have the Modified file unstaged and i have help.txt to unstaged if i go into my code i can see my changes. i am back to where i was. 

c) View Log History
-------------------
Now since we have done a reset i.e reverted our code from 59b07b5 to b481765 but doing a reset on b481765. Now lets check our logs.
$ git log --oneline --decorate --graph
* b481765 (HEAD -> learn-reset, java-mk) mkyong tutorials added.
* 95cceb9 (origin/master, origin/HEAD, master) New Code Added to Master
*   8a03733 Merge branch 'march'

We can see that the commit id 59b07b5 is no longer there in the logs. Means we have come back where we left.

Now we have learned that by reseting we can make changes in my local repository I don't loose my changes even if i have added a file or made changes on other files by doing a soft reset and what we have been doing so far is a soft reset which basically means we are going to reset back but we are not going to delete or clean anything. So we saw that we can do that for an entire set of changes that have been staged and unstaged then on our commit. We also saw that we could actually do a commit and then reset back to a previous commit but keep the changes we have done. 

d) View Status
--------------
And that i am pointing to b481765 which is where i left off.
$ git status
On branch learn-reset
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   help.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        reset.txt

no changes added to commit (use "git add" and/or "git commit -a")

I still have 2 files changed 1 file help.txt is in the staging area  and 1 file reset.txt n the untracked files.

So far we have seen a soft reset which is farely safe and gets us back to where we started with out having anything tracked but essentially leaves our changes that we have done in place.

-----------------------------------------
 + Hard Reset and Clean on current commit
-----------------------------------------
Soft reset is fairly safe because we didn't loose our changes and we are really in a solid state and our repository. And we are working on our local repository so reseting our history didn't cause any problems for ourselves. So once again before we do any history rewriting or reseting its important to remember that you are going to want to make sure that you dont do history rewriting again say publically pushed repository branch because you don't want to modify or change the history maybe somebody is relying on that history. So we are still working locally so we are good. But we have to be careful to remember that if we do this any unstaged and uncommited changes will be lost. But basically what we are going to do is hard reset.

So what we did is we have 2 files one help.txt and the other reset.txt we modified the help.txt by adding a new line. And we added a new file reset.txt. Now when i type git status
$ git status
On branch learn-reset
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   help.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        reset.txt

no changes added to commit (use "git add" and/or "git commit -a")

I can see that in my working directory i have one modified file help.txt and an untracked file reset.txt.

Scenario-1
Now i have made the change and now i don't want the changes so i am going to do a hard reset. Basically when we do a hard reset the entire changes will be lost. The syntas is 
$ git reset head --hard
where we need to explicitly mention the --hard option for hard reset.

a) Revert and discard the changes
---------------------------------
$ git reset head --hard
	HEAD is now at b481765 mkyong tutorials added.
Now we have done a hard reset, now lets verify this by checking the status

b) Status 
---------
$ git status
On branch learn-reset
Untracked files:
  (use "git add <file>..." to include in what will be committed)

        reset.txt

nothing added to commit but untracked files present (use "git add" to track)

Now if we see the hard reset output "HEAD is now at b481765 mkyong tutorials added." it confirmed that we reverted back to the last commit. And the help.txt is no longer present in the working directory. But the reset.txt is still there because its an untracked file and git is not aware of the file. If we need to remove reset.txt we have to manually remove it by giving the command $ git rm -f reset.txt







Cleans Command
For deleting a file from a directory you can basically provide the command
$ rm -f fileName;

We also have an alternative to use the clean command to clean up your repository at this point. So with the clean command you can actually do a bunch of different things at once which is really nice. You just need to be careful that you don't delete things that you want to keep. We we will see a couple of way to do a clean opetaion. And if you are working on your repository please don't run these until you know excately what they do.

1. Simple Clean Everything Command
----------------------------------
So the first thing i am going to do is i am going to a very simple clean everything command
git clean -d -x -f

$ git clean -d -x -f
Removing .project
Removing bin/com/xyz/raul/comparator/ds/Lesson1$1.class
Removing bin/com/xyz/raul/comparator/ds/Lesson1.class
Removing bin/com/xyz/raul/comparator/ds/PersonComparator.class
Removing reset.txt

The above clean command deleted the .project, few classes and reset.txt file. So all the files that was not tracked by Git got deleted.

2.Interactive Clean
-------------------
We also have a safer clean activity. So we can make sure that if there are *.class files we can ensure that the files we want won't be deleted. This is called as interactive clean

Befor that we need to create a folder called thirdpary and store two files viz configuration.dll and swap.dll. And we don't want to delete or clean these files as there are important libraries for our appln.
Now if we see the status
 $ git status
On branch learn-reset
nothing to commit, working tree clean

since the 2 files configuration.dll and swap.dll is not listed because *.dll is included in the .gitignore file. So i go a git clean those *.dll would potentially be gone. So what i want to do is perform an interactive clean. the interactive clean has the below syntax
$ git clean -x -d -i
where i stands for interactive clean

$ git clean -d -x -i
Would remove the following item:
  thirdpary/
*** Commands ***
    1: clean                2: filter by pattern    3: select by numbers
    4: ask each             5: quit                 6: help
What now>

based on our need we need to select the appropriate numbers here i choose option 1 so the third party folder will be removed.
What now> 1
Removing thirdpary/

Now lets see the askEach option
-------------------------------

For that we will create the folder 3rdparty add few files viz file1.dll, file2.dll, file3.dll and file4.dll in the 3rdpary folder.
Now i provide the interactive clean command
$ git clean -d-x -i

$ git clean -d -x -i
Would remove the following items:
  file1.dll  file2.dll  file3.dll  file4.dll
*** Commands ***
    1: clean                2: filter by pattern    3: select by numbers
    4: ask each             5: quit                 6: help
What now>
Choose the opton 4
What now> 4
Remove 3rdpary/ [y/N]? n
Remove file1.dll [y/N]? y
Remove file2.dll [y/N]? y
Remove file3.dll [y/N]? y
Remove file4.dll [y/N]? n
Removing file1.dll
Removing file2.dll
Removing file3.dll

Now all the files are deleted. Now the interactive option is bit simple where we can see each file  once verified the files are removed.


---------------------------------------------------
 + Hard Rest on previous commit & merge into master
---------------------------------------------------
In this session we are going to reset to our previous commit in our history. 

Note : This is a very dangerous thing to do, so reseting to a previous commit is going to give us a chance to completely wipe out changes as well as destroy our history. And if we do this and publish out to our master and there could be other developeers who would depend on the history then we could really cause them a huge problem. Once again double think and do only if you need or not.

Now lets check out git log
$ git log --oneline
b481765 (HEAD -> java-mk) mkyong tutorials added.
95cceb9 (origin/master, origin/HEAD, master) New Code Added to Master
8a03733 Merge branch 'march'
2afe7de (origin/march) Git Command modified
76ba67b Merge branch 'march to master
c5d3915 Repo modified, GIT Commands added and gitignore modified
1f48b6c accedental commit of .class file removed and gitignore file modified
d415fa6 Consumer Note file
f9c2b7d Adding index.html file
32dc965 New Version Added for Git Commit File
1488187 Deleting old Git Command File
9f7cee9 Commiting file help.txt
68b64e2 Added Contribution description for help.txt
fb9ad5f Introduction description added for help.txt
ed9f0c6 Deployment description added for help.txt
740d4c5 Description added for help.txt
b22194c File Added and Initial Comments added for help.txt fileFile Added and Initial Comments added for help.txt file
264cfa5 Merging and Branching Added
2998918 Modified the Git File to add
c1f4298 Git File
9723d5b Added Numbers from 6 to 8
b8756ca Numbers from 1 to 5 added.
28d9431 README.md file added.
60ffc6c Added Description in README.md
bd72a2d Adding Description
a46c5fa Added Deployment in README.md
da9df88 Adding README.md File
2db1f21 Removed Space
cd2be8e Function and Function Chaining
48e5629 Function added
e82ddf7 first commit

Now we have implemented different changes and our history has grown. Now lets say we identified a bug 1f48b6c,now i actually want to go to this particular commit and fix the bug. Because i have the further history from c5d3915 to b481765 (changes after 1f48b6c already pushed to master) so after fixing the bug if i need to push this to master i have to do a lot of steps and these won't be covered in this session. But what we will see in this session is we will reset back to another commit and start working on the commit to fix the bug and alternatevely you can do some merging and stuff even if you didn't know some stuff called rebasing. Once you do the change if you merge into the current master and resolve any conflicts if any then that should take care of it.

So we will get back to 1f48b6c and provide the bug fix.

1.Switching back to our previous commit 1f48b6c
$ git reset 1f48b6c --hard

eg:
$ git reset 1f48b6c --hard
HEAD is now at 1f48b6c accedental commit of .class file removed and gitignore file modified

where HEAD is now pointing to the commit 1f48b6c and followed by the commit message "accedental commit of .class file removed and gitignore file modified"

so any change which we make will result only in the current branch. 

2.Now provide the bug fix.
Now we have switched to the 1f48b6c, and we have provided the fix. Apply our usual steps to commit the code
a.Check the status $ git status -s/w
b.Provide the commit message $ git commit -am "Fixed the bug 1f48b6c" once commited we get a new commit message.
c.Now the next step is to merge the newly commited code to the master and resolve any conflicts is present.

By doing these 3 steps i will ensure that my bug fix is moved to master. 

So from this session we understood that we can go back to one particular commit make changes and move forward and that's what reset allows us to do.


---------------------------------------------------
 + Reverting a commit
---------------------------------------------------

In this session we are going to see how to reverting a commit. So the git 'revert' command is a very safe way to undo something in the public history and you shouldn't have to worry about something breaking as long as you do it quickly and don't have people again going divergent off the commit that you are reverting. So all that we are going to do with a revert is undo or basically rewind the changes that were done so git is smart enough to do that for us. so its easy to do those changes so lets go forward and just quickly do a revert branch here.

1.Create a new branch revert-commit
-----------------------------------
$ git checkout -b revert-commit

2.Make changes in the help.txt file
-----------------------------------
Included the Subscribe part in the help.txt file and save it.

3.Add and Commit the changes
----------------------------
We do an express commit to push the code.
$ git commit -am "Subscribe part included"
[revert-commit d2190ba] Subscribe part included
 1 file changed, 3 insertions(+)

4.View the logs
$ git log --oneline
d2190ba (HEAD -> revert-commit) Subscribe part included
b481765 (java-mk) mkyong tutorials added.
95cceb9 (origin/master, origin/HEAD, master) New Code Added to Master
8a03733 Merge branch 'march'

Now we can see the newly commit d2190ba.

Now the good thing about a revert is it will not change the history its going to keep everything as it is. Its going to create a new commit which undoes  d2190ba. Also if i was to push this out publicly we could see that the history would not change there as well. But we are going to do this locally to save us some time and we can understand that reverting is just going to make it happen in reverse.

4.To view the different options of revert
-----------------------------------------
$ git revert
usage: git revert [<options>] <commit-ish>...
   or: git revert <subcommand>

    --quit                end revert or cherry-pick sequence
    --continue            resume revert or cherry-pick sequence
    --abort               cancel revert or cherry-pick sequence
    -n, --no-commit       don't automatically commit
    -e, --edit            edit the commit message
    -s, --signoff         add Signed-off-by:
    -m, --mainline <parent-number>
                          select mainline parent
    --rerere-autoupdate   update the index with reused conflict resolution if possible
    --strategy <strategy>
                          merge strategy
    -X, --strategy-option <option>
                          option for merge strategy
    -S, --gpg-sign[=<key-id>]
                          GPG sign commit
So in our example we need to give the actual commit because we need to revert on the commit.

5.Reverting based on commit
---------------------------
So we need to revert on the commit d2190ba.
$ git revert d2190ba
[revert-commit 6d50eac] Revert "Subscribe part included as per the client...."
 1 file changed, 3 deletions(-)

This will open up a text editor since we didn't provie any commit message. Once done you can see the above response.

6.View the log to see the history
---------------------------------
$ git log --oneline
6d50eac (HEAD -> revert-commit) Revert "Subscribe part included as per the client...."
d2190ba Subscribe part included
b481765 (java-mk) mkyong tutorials added.

Now we can see a new commit 6d50eac which has reverted all the codes that we did on d2190ba.

7.Open the files to view the changes whether revert is success or not
---------------------------------------------------------------------
open help.txt file
now we can see that the suggestion part is removed from the help.txt file. And the same exact situation that it was in before we had made our change. 
hence we have reverted our code based on a commit. So 6d50eac and b481765 are now both the same we can cross-verify using git diff.

Note : --There is not limit to how many commits we can revert

So in this session what we did is we basically made a changes to help.txt by including the subscription part and reveted it back to where we were and the histry is stayed intact. That means if we push this to public we wouldn't have to worry about breaking someone elses references because those commits would still be there or atleast d2190ba would be there that they are relying on and then our revert could be merged into theirs as well. And it would basically undo that commit and their history would stay okay and our branches would still be able to be easily merged.

So that's wraps up todays session for our revert command.


---------------------------------------------------
 + Introduction to Rebasing
---------------------------------------------------

The main aim of doing a rebase is to have a linear commit history and to make it look like we never branched off Master. And it basically keeps our commits in a more ordered fashion. You can also do this if you were moving things around and you wanted to change your history a little bit and you needed to place things in a specific spot in history. So we will understand more by doing a deep dive.

1. Create a new branch called feature1
-/training/github/learn-java-8 (master)
$ git checkout -b feature-1
Switched to a new branch 'feature-1'

2. From the feature-1 branch do some changes and do multiple commit
- Open help.txt and add Subscribe section
- Open Git Command and add the latest
- Open gitignore and add .settings.	

And now if i see the logs
- /training/github/learn-java-8 (feature-1)
$ git log --oneline
24d9d13 (HEAD -> feature-1) .settings added in gitignore
e5025d8 Added more on Git commands
b5f0746 Subscribe part added
95cceb9 (origin/master, origin/HEAD, master) New Code Added to Master
8a03733 Merge branch 'march'

Now we can see that we have 3 commits 24d9d13,e5025d8 and b5f0746 in feature 1 branch. We took the feature 2 branch from master on this commit 95cceb9

3. Now Assume developer 2 created another feature branch called feature-2 from master
- /training/github/learn-java-8 (master)
$ git checkout -b feature-2
Switched to a new branch 'feature-2'

4. From the feature-2 branch do some changes and do multiple commit
- Open Execute class and add starting point log.
- Open count.txt and add comment regarding rebasing.

- /training/github/learn-java-8 (feature-2)
$ git log --oneline
d04dbf9 (HEAD -> feature-2) Count.txt file modified for rebasing
2d73b71 Comment added
95cceb9 (origin/master, origin/HEAD, master) New Code Added to Master
8a03733 Merge branch 'march'
2afe7de (origin/march) Git Command modified

Now we can see that we have 3 commits d04dbf9 and 2d73b71 in feature 2 branch. We took the feature 2 branch from master on this commit 95cceb9


5. Now Developer 3 did some changes in the master branch and comitted.
Now if we see the logs before the changes
- /training/github/learn-java-8 (master)
$ git log --oneline

95cceb9 (HEAD -> master, origin/master, origin/HEAD) New Code Added to Master
8a03733 Merge branch 'march'
2afe7de (origin/march) Git Command modified

We can see that our master branch is still pointing at 95cceb9 so now we  do the changes and commit locally.

- Open index.html and added the tags.

 - /training/github/learn-java-8 (master)
$ git log --oneline
e8b5883 (HEAD -> master) index.html modified to add tags
95cceb9 (origin/master, origin/HEAD) New Code Added to Master

Now we can see e8b5883 has been added to master. So now our master branch has moved ahead a commit so feature-1 and feature-2 are essentially on their own trees all of them have a common ancestor 95cceb9 commit and what we want to is we want to have developer 2 create his change is a way that 2d73b71(first commit of feature-2) should directly follow e8b5883 (last commit of master)

So again we are going to rewriting history here so you need to be very careful you don't want to rewrite the history of master but you can re-write the history of your feature branch as long as no one's dependent on them or you are not even public. So what you would do is bring the changes down and do the rebase locally. And when you push it up it will nicely merge. Ofcourse if there is a confilict during the rebase be prepared to resolve that conflict. And its natural, its just essentially doing somewaht of a merge and it basically makes sure that your code will have the history to the point where the Master was and it will look like you took off from master and went forward.

So after the rebase and merge 2d73b71 should follow e8b5883 once we are done.

6. Rebase feature-2 to master
Now make sure that i am on the branch that i need to do a rebase, so make sure that i am on feature-2
So if i had to pull master and get everything up to date on my local i could then checkout feature-2 and then what i can do is just simply provide the git rebase command. The syntax is 
$ git rebase <branch name>

 - /training/github/learn-java-8 (feature-2)
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: Comment added
Applying: Count.txt file modified for rebasing

Now if we look at the logs

 - /training/github/learn-java-8 (feature-2)
$ git log --oneline
86c50c3 (HEAD -> feature-2) Count.txt file modified for rebasing
84465e5 Comment added
e8b5883 (master) index.html modified to add tags
95cceb9 (origin/master, origin/HEAD) New Code Added to Master
8a03733 Merge branch 'march'
2afe7de (origin/march) Git Command modified
76ba67b Merge branch 'march to master
c5d3915 Repo modified, GIT Commands added and gitignore modified

Now from the logs we can see that feature-2's new commit 84465e5 follows e8b5883 commit. So again we re-wrote history which is why its important to remember that we don't want these 2 commits to be dependent on anybody else's tree. 

7. Merge Master with feature-2
So for this first switch to master branch
 - /training/github/learn-java-8 (feature-2)
$ git checkout master
Switched to branch 'master'
Your branch is ahead of 'origin/master' by 1 commit.
  (use "git push" to publish your local commits)
  
So now we go the merge of feature-2
 - /training/github/learn-java-8 (master)
$ git merge feature-2
Updating e8b5883..86c50c3
Fast-forward
 src/com/xyz/raul/ExecuteTest.java | 2 +-
 src/com/xyz/raul/util/count.txt   | 4 +++-
 2 files changed, 4 insertions(+), 2 deletions(-)
 
So this is basically they pulled down the branch the branch they rebased on the master and now they pushed up and we are going to do the pull request where we are going to merge feature two into master.
 
So now we can delete the feature 2
 
8.Delete feature-2 branch
Since we have merged the feature-2 branch on to master we no longer need them. So we delete feature-2 branch
  - /training/github/learn-java-8 (master)
$ git branch -d feature-2
Deleted branch feature-2 (was 86c50c3).

9.View the master log to see linear commits.
 - /training/github/learn-java-8 (master)
$ git log --oneline
86c50c3 (HEAD -> master) Count.txt file modified for rebasing
84465e5 Comment added
e8b5883 index.html modified to add tags
95cceb9 (origin/master, origin/HEAD) New Code Added to Master

Now we can see linear commit's and the feature we implemented by looking at the logs its understood we have worked in the master branch it self. And all our changes that we did for feature-2 was added or appended to master.

10. Now we do the similar steps to feature-1
- Switch on to feature-1 branch
 - /training/github/learn-java-8 (master)
$ git checkout feature-1
Switched to branch 'feature-1'

- Perform rebase
After rebase we can see b5f0746(first commit of feature-1) will be followed the 86c50c3 (the last commit of master)
 - /training/github/learn-java-8 (feature-1)
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: Subscribe part added
Applying: Added more on Git commands
Applying: .settings added in gitignore

- Switch to master branch
 - /training/github/learn-java-8 (feature-1)
$ git checkout master
Switched to branch 'master'
Your branch is ahead of 'origin/master' by 3 commits.
  (use "git push" to publish your local commits)

- Perform merge 
 - /training/github/learn-java-8 (master)
$ git merge feature-1
Updating 86c50c3..779b2ba
Fast-forward
 .gitignore      |    3 +-
 GIT Command.txt | 1985 ++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 help.txt        |    4 +-
 3 files changed, 1981 insertions(+), 11 deletions(-)

- View the logs
 - /training/github/learn-java-8 (master)
$ git log --oneline
779b2ba (HEAD -> master, feature-1) .settings added in gitignore
302abdd Added more on Git commands
99075f4 Subscribe part added
86c50c3 Count.txt file modified for rebasing
84465e5 Comment added
e8b5883 index.html modified to add tags
95cceb9 (origin/master, origin/HEAD) New Code Added to Master
8a03733 Merge branch 'march'
2afe7de (origin/march) Git Command modified
76ba67b Merge branch 'march to master
c5d3915 Repo modified, GIT Commands added and gitignore modified


Now we can see the new commit id 99075f4 Subscribe part added is followed 86c50c3 (the last commit of master)

 - /training/github/learn-java-8 (master)
$ git branch -d feature-1
Deleted branch feature-1 (was 779b2ba).

And now what we have is one solid linear history of all the commits that we ultimately rebased on to master. And that's the introduction and what are we trying to accomplish with rebasing. Basically we are re-writting history so that we can make it look like commit started after a different commit or essentially change the order of commits in history.



 + Rebasing activity with local squash
--------------------------------------


For this activity all we need is to create a new branch, and do or 3 commits on the branch and we are going to squash them down using an interactive rebase. 

1. Create a new branch feature-2
/-/training/github/learn-java-8/3rdpary(master)                                                                                 

$ git checkout -b feature-2
Switched to a new branch 'feature-2'

2. Do some changes and commit the code.
 - Open help.txt and add the below lines

## Share
	If you like the video please do share by clicking the below link.
	
 - Commit the Changes
   $ git commit -am "help.txt local squash commit-1" 	

 - For our second commit open index.html and add the following lines
 
<p>Copy Url to Share the video to friends and family: <a href="mailto:someone@example.com">
		  someone@example.com</a>.</p> 
 - Commit the Changes
   $ git commit -am "index.html added link for sharing video local squash commit-2" 
 
 - Now for the third change open README.md file and add the below lines

## Share
	If you like my video's please do share it with your friends and family. 
 
 - Commit the Changes
   $ git commit -am "README.md added description in README.md about sharing video link local squash commit-3" 	
   
  - Now for the third change open GitCommand.txt file and make changes
  - Commit the Changes
  $ git commit -am "GitCommand.txt file modified local squash commit-4" 	

3. View the commit history
 - /training/github/learn-java-8 (feature-2)
$ git log --oneline
49e0f16 (HEAD -> feature-2) GitCommand.txt file modified local squash commit-4
d9c00ed README.md added description in README.md about sharing video link local squash commit-3
08ca084 index.html added link for sharing video local squash commit-2
9ee2842 help.txt local squash commit-1
779b2ba (master) .settings added in gitignore

So now we can see the 4 commits we did 
49e0f16 (HEAD -> feature-2) GitCommand.txt file modified  local squash commit-4
d9c00ed README.md added description in README.md about sharing video link local squash commit-3
08ca084 index.html added link for sharing video local squash commit-2
9ee2842 help.txt local squash commit-1

As of now these commit's are on my local machine, we are yet to push this to master.

4. Take pull from master.
- Switch on to master
 - /training/github/learn-java-8 (feature-2)
$ git checkout master
Switched to branch 'master'
Your branch is ahead of 'origin/master' by 6 commits.
  (use "git push" to publish your local commits)
  
- Take a pull and ensure
 - /training/github/learn-java-8 (master)
$ git pull origin master
If there were any updated files then its now available on our local git. Now we switch on to our feature branch and do the rebase & merge activity.

5. Switch to our feature-2 branch
$ git checkout feature-2
Switched to branch 'feature-2'

6. Do a git status to ensure there are no modified files
$ git status -s

So there are no changes but we know that we are 6 commit ahead of master. 


7.Why Squash ?
if we view the log we can see that we have 4 commits
49e0f16 (HEAD -> feature-2) GitCommand.txt file modified local squash commit-4
d9c00ed README.md added description in README.md about sharing video link local squash commit-3
08ca084 index.html added link for sharing video local squash commit-2
9ee2842 help.txt local squash commit-1

Now instead of displaying as 4 commits i want to combine all these 4 commits into 1 single commit. For this we squash all the 4 commits into 1 single commit. And merge that single commit on top of master.

i.e we need not have all 4 commits on our tree we only need one commit. This was all just feature work on the branch. And as long as the feature is working we would do one commit. So in order to do that we need to do an interactive rebase.

8.Interactive Rebase
For verifying the first step is do a reflog

 - /training/github/learn-java-8 (feature-2)
$ git reflog
49e0f16 (HEAD -> feature-2) HEAD@{0}: checkout: moving from master to feature-2
779b2ba (master) HEAD@{1}: checkout: moving from feature-2 to master
49e0f16 (HEAD -> feature-2) HEAD@{2}: commit: GitCommand.txt file modified
d9c00ed HEAD@{3}: commit: README.md added description in README.md about sharing video link local squash commit-2
08ca084 HEAD@{4}: commit: index.html added link for sharing video local squash commit-1
9ee2842 HEAD@{5}: commit: help.txt local squash commit
779b2ba (master) HEAD@{6}: checkout: moving from master to feature-2

So basically we have 4 commits on top of master, highlight the word commit and you can see there are 4 commit actions done after we did a checkout from master.
But now what i know is that with those 4 commits i want to move back head 4 commits for my rebase. So basically i want to go back 779b2ba.

For going back to 779b2ba i need to provide the command
$ git rebase -i HEAD~4

Now the default text editor opens with the following lines
pick 9ee2842 help.txt local squash commit-1
pick 08ca084 index.html added link for sharing video local squash commit-2
pick d9c00ed README.md added description in README.md about sharing video link local squash commit-3
pick 49e0f16 GitCommand.txt file modified local squash commit-4

Once you provide -i option this is going to try to resolve where i am trying to go and get the rebase to happen. what it says is we need to pick one commt which is going to be because ultimately we are going to have a new commit. So we choose 9ee2842 for commit and squash the other three.
This can be done by replacing pick keyword with squash for the remaining 3 commits.

------------------------------------------------------------------------------------------------------
pick 9ee2842 help.txt local squash commit
squash 08ca084 index.html added link for sharing video local squash commit-1
squash d9c00ed README.md added description in README.md about sharing video link local squash commit-2
squash 49e0f16 GitCommand.txt file modified
------------------------------------------------------------------------------------------------------
Now this will complete my rebase we are going to do a save this basic command reference here so go ahead and pick 9ee2842 this commit and squash the other 3 commits to it. So we will have for commit's squashed to one and commit that on rebase. So we save that goahead and close the file.
Now it will try to rebase them automatically, if there are conflicts then we need to resolve them to proceed further.

Again the text editor opens for providing the commit message. What it does is it shows all the commit message that i have added. So either we can provide all the 4 commit message's or provide a new one by commenting the other 4 with '#'. So in this case commented the other 4 and added a new commit message.

We choose the commit message "Interactive Rebase Activity completed converted 4 commit's into a single commit using Squash." So we save that goahead and close the file.

The output message after successful rebase is 
$ git rebase -i HEAD~4
[detached HEAD a4e2d62] Interactive Rebase Activity completed converted 4 commit's into a single commit using Squash.
 Date: Wed Jan 6 10:51:32 2021 +0530
 4 files changed, 51 insertions(+), 3 deletions(-)
Successfully rebased and updated refs/heads/feature-2.

Now this commit id a4e2d62 is created with the commit message "Interactive Rebase Activity completed converted 4 commit's into a single commit using Squash."

9.View the log history
 - /training/github/learn-java-8 (feature-2)
$ git log --oneline
a4e2d62 (HEAD -> feature-2) Interactive Rebase Activity completed converted 4 commit's into a single commit using Squash.
779b2ba (master) .settings added in gitignore

Now that we can see our previous 4 commits 9ee2842,08ca084,d9c00ed and 49e0f16 were actually combined into a single commit a4e2d62 with the new commit message we provide while doing an interactive rebase. This new commit a4e2d62 is put on top of master.

And we have a bunch of references left behind from the operations that happended but ultimately we have successully squashed local so we can do our quick cleanup's as well.
Do refer the git help to see how to clean detached references.

10.Now the final step is to merge the changes to our master branch
- Switch to master branch
 $ git checkout master
Switched to branch 'master'
Your branch is ahead of 'origin/master' by 6 commits.
  (use "git push" to publish your local commits)


- Perform merge 
 - /training/github/learn-java-8 (master)
 - /training/github/learn-java-8 (master)
$ git merge feature-2
Updating 779b2ba..a4e2d62
Fast-forward
 GIT Command.txt | 43 ++++++++++++++++++++++++++++++++++++++++++-
 README.md       |  4 +++-
 help.txt        |  5 ++++-
 index.html      |  2 ++
 4 files changed, 51 insertions(+), 3 deletions(-)


- View the logs
 $ git log --oneline
a4e2d62 (HEAD -> master, feature-2) Interactive Rebase Activity completed converted 4 commit's into a single commit using Squash.
779b2ba .settings added in gitignore

Now that we can see our previous 4 commits 9ee2842,08ca084,d9c00ed and 49e0f16 were actually combined into a single commit a4e2d62 with the new commit message we provide while doing an interactive rebase. 

Now push master to remote.

11.Clean Up
As part of clean up process delete feature-2 branch
 - /training/github/learn-java-8 (master)
$ git branch -d feature-2
Deleted branch feature-2 (was a4e2d62).


--------------------------------------
 + Cherrypick
--------------------------------------

In this session we will understand cherrypick operation. So similar to rebasing we are going to move some commits around but this time we are going to cherry pick part of the chain of commit's we are going to make and this will show us that we can take only one commit in its entirely and apply that to our chain as a rebase on top of the master.

So unlike our previous activities we are going to create a new branch and quickly add some changes and commit the changes.

1.Create a new branch 'cherrypickdemo'
 -/training/github/learn-java-8 (master)
$ git checkout -b cherrypickdemo
Switched to a new branch 'cherrypickdemo'

2.Do some changes on to a single file
So we need to do 3 or 4 commits on a single file, this helps us to easily remember the order of the commit. So what we need to remember is that every operaton we add will be as individual commits so we can pick on a commit from a chain of commits we will also get the chain one commit as well.
For this we take our help.txt file and do 3 to 4 commits.
 - Add the below code in help.txt file
 ## To Understand Cherry Pick
	Commit -1 : Cherry Pick Demo Commit-1
 - $ git commit -am "Cherry Pick Demo Commit-1"
[cherrypickdemo b6f2f28] Cherry Pick Demo Commit-1
 1 file changed, 4 insertions(+), 1 deletion(-)
 
 - Do another change and commit
	Commit -2 : Cherry Pick Demo Commit-2
 - $ git commit -am "Cherry Pick Demo Commit-2"
[cherrypickdemo 0d976af] Cherry Pick Demo Commit-2
 1 file changed, 2 insertions(+), 1 deletion(-)
 
 - Do another change and commit
	Commit -3 : Cherry Pick Demo Commit-3
 - $ git commit -am "Cherry Pick Demo Commit-3"
[cherrypickdemo 85b507b] Cherry Pick Demo Commit-3
 1 file changed, 2 insertions(+), 1 deletion(-)
 
 - Do another change and commit
	Commit -4 : Cherry Pick Demo Commit-4
 - $ git commit -am "Cherry Pick Demo Commit-4"
[cherrypickdemo 0a5b0c3] Cherry Pick Demo Commit-4
 1 file changed, 2 insertions(+), 1 deletion(-)
 
 But when you do a cherry pick you basically get what you do on your pick based on what's already there in that commit so cherry picking commit-2 will also get cherry picking commit-1 because its a part of it. So we have all of our stuffs in place and there are 4 cherry pick commits are here by ready to go.
 
  - /training/github/learn-java-8 (cherrypickdemo)
$ git log --oneline
0a5b0c3 (HEAD -> cherrypickdemo) Cherry Pick Demo Commit-4
85b507b Cherry Pick Demo Commit-3
0d976af Cherry Pick Demo Commit-2
b6f2f28 Cherry Pick Demo Commit-1
a4e2d62 (master) Interactive Rebase Activity completed converted 4 commit's into a single commit using Squash.

2.35
And our master is at a4e2d62


------------------
 + Tags or Tagging
------------------
Tags are really nice way to put bookmarks in place on our commits that are easily to find and use in the future. They also give us a way to publish information about who tagged it and when and why. For nice things like versioning but also once we get tags in place what we see is if we push them out they actually create releases that we can easily get to github. So my tags that i have in place are all right here.(In Github UI releases tab, and release) It shows me the commit ID and so i can easily find that it also allows me to download the repository in excately that spot where i create the tags. There are two type of tags
1. Lightweight
2. Annotated
The main difference is the lightweight tag is like a bookmark to a specific place that you would want to use if you want to get back to that spot and an annotated tag allows you to make a tag that you can put your informatino about who did it what all the state of the thing was when it was done. And so there is an as a tag commit message as well. And so thats very nice information if you are doing official releases. For example you would want to use an annotated tag whereas if its just mostly for your locally or for your team locally or whatever you could you know create a quick couple of bookmark tags and use those.

Listing of Tags
---------------
To list all the tags that we have created. Syntax is 
$ git tag.
Also $ git tag -l or git tag -list all does the same operation.

To Go to one Tag
----------------
To access or open a tag is simple as checking out a branch. Instad of branchName we provide the tagName. And the syntax is
$ git checkout tagName
Not it tells you that you are in a detached state and tells me where i am at and it shows excately there where i am in my detached head.It is in the detached stage just like if we directly checked out the commit. So if I want to do some changes from this point i would need to create a new branch off of where i am at and then make those changes and if i need to get those in a master merge them in. Thats a good understanding and we wil try to implement the same.

Adding New Tags
---------------
a)Lightweight Tag
The general syntax of createing a light weight tag is
$ git tag tagname
where tagName is the name given to the newly created tag.

eg: $ git tag OnMasterRightNow
So we just added a tag that's lightweight tag and i know its lightweight becasue i didn't use the dash to annotate it and i didn't give any message. So its a lightweight tag. Consider it like a pointer or bookmark to a commit.

a)Annotated Tag
If i want to create an annotate tag the syntax is slight different i would need to provide -a attribute. The general syntax is 
$ git tag -a tagName 
eg: git tag -a OnMasterAnnotatedLatestRightNow
If we provide like this then an editor will be opened and you need to provide the comments. Or else we can provide the message by providing the option -m during tag creation.
$ git tag -a OnMasterAnnotatedWithCommentsRightNow -m "Commenting why the tag was created and what's the intent"
So that will give me that annotated tag on Master annotated which look excately the same but it has lot of other informations stored in the actual master annotated object which is then stored. This is actually an object stored in your references locally. where the master right now lightweight tag is just a pointer.
So if i want to take a look for eg I could say git show on MasterAnnotted 
$ git show OnMasterAnnotatedLatestRightNow
And that tells me the information of that commit based on that tag. There is not annotated tag information. So that's the biggest difference b/w a lightweight and annotated tag other that the fact of how they are stored locally.
So the nice thing about this is once you have a tagging schema in place such as you know if you are doing a versino 1 or version 2 or version 3 with the one v1. or v2 dot and you did a bunch of versions. You could get all the tags for a specific verion or in this case i am going to get them for on master and all i need to do that is say 
get tag -l and then the basically almost like a regular expression 
eg:
$ git tag -l "OnMas*"
-----------------
/training/github/learn-java-8 (master)
$ git tag -l "OnMas*"
OnMasterAnnotatedLatestRightNow
OnMasterAnnotatedRightNow
OnMasterAnnotatedWithCommentsRightNow
OnMasterRightNow
---------------------------------------
And what that will do is list out all the tags that match so you can imagine if i had Version 1, Verison 2 i can get that. So that's a really nice feature to quickly get a group of tags if your are looking for that sort of functionality.

Also i can tag to a specific commit. Its not necessary that i can tag only at the point i am.

For Eg when i check the log
/training/github/learn-java-8 (master)
$ git log --oneline
a4e2d62 (HEAD -> master, tag: OnMasterRightNow, tag: OnMasterAnnotatedWithCommentsRightNow, tag: OnMasterAnnotatedRightNow, tag: OnMasterAnnotatedLatestRightNow) Interactive Rebase Activity completed converted 4 commit's into a single commit using Squash.
779b2ba .settings added in gitignore
302abdd Added more on Git commands
99075f4 Subscribe part added
86c50c3 Count.txt file modified for rebasing
84465e5 Comment added
e8b5883 index.html modified to add tags
95cceb9 (origin/master, origin/HEAD) New Code Added to Master
8a03733 Merge branch 'march'
2afe7de (origin/march) Git Command modified
76ba67b Merge branch 'march to master
c5d3915 Repo modified, GIT Commands added and gitignore modified
1f48b6c accedental commit of .class file removed and gitignore file modified
d415fa6 Consumer Note file
f9c2b7d Adding index.html file
32dc965 New Version Added for Git Commit File
1488187 Deleting old Git Command File















